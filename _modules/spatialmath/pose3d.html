

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spatialmath.pose3d &mdash; Spatial Maths package  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Spatial Maths package
              <img src="../../_static/CartesianSnakes_LogoW.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spatialmath.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indices.html">Indices</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Spatial Maths package</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spatialmath.pose3d</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spatialmath.pose3d</h1><div class="highlight"><pre>
<span></span><span class="c1"># Part of Spatial Math Toolbox for Python</span>
<span class="c1"># Copyright (c) 2000 Peter Corke</span>
<span class="c1"># MIT Licence, see details in top-level file: LICENCE</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes to abstract 3D pose and orientation using matrices in SE(3) and SO(3)</span>

<span class="sd">To use::</span>

<span class="sd">    from spatialmath.pose3d import *</span>
<span class="sd">    T = SE3.Rx(0.3)</span>

<span class="sd">    import spatialmath as sm</span>
<span class="sd">    T = sm.SE3.Rx(0.3)</span>


<span class="sd"> .. inheritance-diagram:: spatialmath.pose3d</span>
<span class="sd">    :top-classes: collections.UserList</span>
<span class="sd">    :parts: 1</span>

<span class="sd">.. image:: ../figs/pose-values.png</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># pylint: disable=invalid-name</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">spatialmath.base</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">smb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.base.types</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.base.vectors</span><span class="w"> </span><span class="kn">import</span> <span class="n">orthogonalize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.baseposematrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">BasePoseMatrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.pose2d</span><span class="w"> </span><span class="kn">import</span> <span class="n">SE2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.twist</span><span class="w"> </span><span class="kn">import</span> <span class="n">Twist3</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.quaternion</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnitQuaternion</span>

<span class="c1"># ============================== SO3 =====================================#</span>


<div class="viewcode-block" id="SO3"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">SO3</span><span class="p">(</span><span class="n">BasePoseMatrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       SO(3) matrix class</span>

<span class="sd">       This subclass represents rotations in 3D space.  Internally it is a 3x3</span>
<span class="sd">       orthogonal matrix belonging to the group SO(3).</span>

<span class="sd">    .. inheritance-diagram:: spatialmath.pose3d.SO3</span>
<span class="sd">       :top-classes: collections.UserList</span>
<span class="sd">       :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">SO3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">SE3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">SO3Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SO3Array</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SO3</span><span class="p">,</span> <span class="n">SO3Array</span><span class="p">]],</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SO3.__init__"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct new SO(3) object</span>

<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        There are multiple call signatures:</span>

<span class="sd">        - ``SO3()`` is an ``SO3`` instance with one value -- a 3x3 identity</span>
<span class="sd">          matrix which corresponds to a null rotation</span>
<span class="sd">        - ``SO3(R)`` is an ``SO3`` instance with with the value ``R`` which is a</span>
<span class="sd">          3x3 numpy array representing an SO(3) rotation matrix.  If ``check``</span>
<span class="sd">          is ``True`` check the matrix belongs to SO(3).</span>
<span class="sd">        - ``SO3([R1, R2, ... RN])`` is an ``SO3`` instance wwith ``N`` values</span>
<span class="sd">          given by the elements ``Ri`` each of which is a 3x3 NumPy array</span>
<span class="sd">          representing an SO(3) matrix. If ``check`` is ``True`` check the</span>
<span class="sd">          matrix belongs to SO(3).</span>
<span class="sd">        - ``SO3([X1, X2, ... XN])`` is an ``SO3`` instance with ``N`` values</span>
<span class="sd">          given by the elements ``Xi`` each of which is an SO3 or SE3 instance.</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">t2r</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad argument to constructor&quot;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_identity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">R3x3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------ #</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the object&#39;s interal matrix representation</span>

<span class="sd">        :return: (3,3)</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        Each value within the ``SO3`` instance is a NumPy array of this shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SO3Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as rotation matrix</span>

<span class="sd">        :return: rotational component</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        ``x.R`` is the rotation matrix component of ``x`` as an array with</span>
<span class="sd">        shape (3,3). If ``len(x) &gt; 1``, return an array with shape=(N,3,3).</span>

<span class="sd">        .. warning:: The i&#39;th rotation matrix is ``x[i,:,:]`` or simply</span>
<span class="sd">            ``x[i]``. This is different to the MATLAB version where the i&#39;th</span>
<span class="sd">            rotation matrix is ``x(:,:,i)``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; x.R</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal vector of SO(3) or SE(3)</span>

<span class="sd">        :return: normal vector</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        This is the first column of the rotation submatrix, sometimes called the</span>
<span class="sd">        *normal vector*.  It is parallel to the x-axis of the frame defined by</span>
<span class="sd">        this pose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only determine n-vector for singleton pose&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">o</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Orientation vector of SO(3) or SE(3)</span>

<span class="sd">        :return: orientation vector</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        This is the second column of the rotation submatrix, sometimes called</span>
<span class="sd">        the *orientation vector*.  It is parallel to the y-axis of the frame</span>
<span class="sd">        defined by this pose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only determine o-vector for singleton pose&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approach vector of SO(3) or SE(3)</span>

<span class="sd">        :return: approach vector</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        This is the third column of the rotation submatrix, sometimes called the</span>
<span class="sd">        *approach vector*.  It is parallel to the z-axis of the frame defined by</span>
<span class="sd">        this pose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only determine a-vector for singleton pose&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SO3.inv"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.inv">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of SO(3)</span>

<span class="sd">        :return: inverse</span>
<span class="sd">        :rtype: SO2 instance</span>

<span class="sd">        Efficiently compute the inverse of each of the SO(3) values taking into</span>
<span class="sd">        account the matrix structure.  For an SO(3) matrix the inverse is the</span>
<span class="sd">        transpose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SO3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SO3</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.eul"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.eul">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">eul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span> <span class="n">flip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">R3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as Euler angles</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of Euler angles</span>
<span class="sd">        :rtype: ndarray(3,), ndarray(n,3)</span>

<span class="sd">        ``x.eul`` is the Euler angle representation of the rotation.  Euler angles are</span>
<span class="sd">        a 3-vector :math:`(\phi, \theta, \psi)` which correspond to consecutive</span>
<span class="sd">        rotations about the Z, Y, Z axes respectively.</span>

<span class="sd">        If ``len(x)`` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(3,N)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.Eul`, :func:`~spatialmath.base.transforms3d.tr2eul`</span>
<span class="sd">        :SymPy: not supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span></div>

<div class="viewcode-block" id="SO3.rpy"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.rpy">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">R3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as roll-pitch-yaw angles</span>

<span class="sd">        :param order: angle sequence order, default to &#39;zyx&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of roll-pitch-yaw angles</span>
<span class="sd">        :rtype: ndarray(3,), ndarray(n,3)</span>

<span class="sd">        ``x.rpy`` is the roll-pitch-yaw angle representation of the rotation.  The angles are</span>
<span class="sd">        a 3-vector :math:`(r, p, y)` which correspond to successive rotations about the axes</span>
<span class="sd">        specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        If `len(x)` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(3,N)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.RPY`, :func:`~spatialmath.base.transforms3d.tr2rpy`</span>
<span class="sd">        :SymPy: not supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span></div>

<div class="viewcode-block" id="SO3.angvec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.angvec">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">angvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">R3</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as angle and rotation vector</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: :math:`(\theta, \hat{\bf v})`</span>
<span class="sd">        :rtype: float or ndarray(3)</span>

<span class="sd">        ``x.angvec()`` is a tuple :math:`(\theta, v)` containing the rotation</span>
<span class="sd">        angle and a rotation axis.</span>

<span class="sd">        By default the angle is in radians but can be changed setting `unit=&#39;deg&#39;`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - If the input is SE(3) the translation component is ignored.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; R = SO3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; R.angvec()</span>

<span class="sd">        :seealso: :meth:`eulervec` :meth:`AngVec` :meth:`~spatialmath.quaternion.UnitQuaternion.angvec` :meth:`~spatialmath.quaternion.AngVec`, :func:`~angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2angvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.eulervec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.eulervec">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">eulervec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as Euler vector (exponential coordinates)</span>

<span class="sd">        :return: :math:`\theta \hat{\bf v}`</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        ``x.eulervec()`` is the Euler vector (or exponential coordinates) which</span>
<span class="sd">        is related to angle-axis notation and is the product of the rotation</span>
<span class="sd">        angle and the rotation axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; R = SO3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; R.eulervec()</span>

<span class="sd">        .. note::</span>

<span class="sd">            - If the input is SE(3) the translation component is ignored.</span>

<span class="sd">        :seealso: :meth:`angvec` :func:`~angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2angvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">v</span></div>

    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SO3.isvalid"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if matrix is valid SO(3)</span>

<span class="sd">        :param x: matrix to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :return: ``True`` if the matrix is a valid element of SO(3), ie. it is a 3x3</span>
<span class="sd">            orthonormal matrix with determinant of +1.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transform3d.isrot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># ---------------- variant constructors ---------------------------------- #</span>

<div class="viewcode-block" id="SO3.Rx"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Rx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from X-axis rotation</span>

<span class="sd">        :param θ: rotation angle about the X-axis</span>
<span class="sd">        :type θ: float or array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SE3.Rx(θ)`` is an SO(3) rotation of ``θ`` radians about the x-axis</span>
<span class="sd">        - ``SE3.Rx(θ, &quot;deg&quot;)`` as above but ``θ`` is in degrees</span>

<span class="sd">        If ``theta`` is an array then the result is a sequence of rotations defined by consecutive</span>
<span class="sd">        elements.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rx(np.linspace(0, math.pi, 20))</span>
<span class="sd">            &gt;&gt;&gt; len(x)</span>
<span class="sd">            &gt;&gt;&gt; x[7]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">rotx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Ry"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Ry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Ry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from Y-axis rotation</span>

<span class="sd">        :param θ: rotation angle about Y-axis</span>
<span class="sd">        :type θ: float or array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Ry(θ)`` is an SO(3) rotation of ``θ`` radians about the y-axis</span>
<span class="sd">        - ``SO3.Ry(θ, &quot;deg&quot;)`` as above but ``θ`` is in degrees</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined by consecutive</span>
<span class="sd">        elements.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Ry(np.linspace(0, math.pi, 20))</span>
<span class="sd">            &gt;&gt;&gt; len(x)</span>
<span class="sd">            &gt;&gt;&gt; x[7]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">roty</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Rz"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Rz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from Z-axis rotation</span>

<span class="sd">        :param θ: rotation angle about Z-axis</span>
<span class="sd">        :type θ: float or array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Rz(θ)`` is an SO(3) rotation of ``θ`` radians about the z-axis</span>
<span class="sd">        - ``SO3.Rz(θ, &quot;deg&quot;)`` as above but ``θ`` is in degrees</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined by consecutive</span>
<span class="sd">        elements.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rz(np.linspace(0, math.pi, 20))</span>
<span class="sd">            &gt;&gt;&gt; len(x)</span>
<span class="sd">            &gt;&gt;&gt; x[7]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">rotz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Rand"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Rand">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rand</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">theta_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from random rotation</span>

<span class="sd">        :param N: number of random rotations</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :param theta_range: angular magnitude range [min,max], defaults to None.</span>
<span class="sd">        :type xrange: 2-element sequence, optional</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation matrix</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Rand()`` is a random SO(3) rotation.</span>
<span class="sd">        - ``SO3.Rand(N)`` is a sequence of N random rotations.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rand()</span>
<span class="sd">            &gt;&gt;&gt; x</span>

<span class="sd">        :seealso: :func:`spatialmath.quaternion.UnitQuaternion.Rand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">smb</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">qrand</span><span class="p">(</span><span class="n">theta_range</span><span class="o">=</span><span class="n">theta_range</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">],</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SO3.Eul"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Eul">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from Euler angles</span>

<span class="sd">        :param 𝚪: Euler angles</span>
<span class="sd">        :type 𝚪: 3 floats, array_like(3) or ndarray(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.Eul(𝚪)`` is an SO(3) rotation defined by a 3-vector of Euler</span>
<span class="sd">          angles :math:`\Gamma = (\phi, \theta, \psi)` which correspond to</span>
<span class="sd">          consecutive rotations about the Z, Y, Z axes respectively. If ``𝚪``</span>
<span class="sd">          is an Nx3 matrix then the result is a sequence of rotations each</span>
<span class="sd">          defined by Euler angles corresponding to the rows of ``angles``.</span>

<span class="sd">        ``SO3.Eul(φ, θ, ψ)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.Eul(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SO3.Eul([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SO3.Eul(10, 20, 30, unit=&quot;deg&quot;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.eul`, :func:`~spatialmath.pose3d.SE3.Eul`, :func:`~spatialmath.base.transforms3d.eul2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">*</span><span class="n">angles</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="s2">&quot;zyx&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">],</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;zyx&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SO3.RPY"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.RPY">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;rad&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;zyx&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from roll-pitch-yaw angles</span>

<span class="sd">        :param angles: roll-pitch-yaw angles</span>
<span class="sd">        :type angles: array_like(3), array_like(n,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param order: rotation order: &#39;zyx&#39; [default], &#39;xyz&#39;, or &#39;yxz&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.RPY(angles)`` is an SO(3) rotation defined by a 3-vector of</span>
<span class="sd">          roll, pitch, yaw angles :math:`(\alpha, \beta, \gamma)`. If ``angles``</span>
<span class="sd">          is an Nx3 matrix then the result is a sequence of rotations each</span>
<span class="sd">          defined by RPY angles corresponding to the rows of angles. The angles</span>
<span class="sd">          correspond to successive rotations about the axes specified by</span>
<span class="sd">          ``order``:</span>

<span class="sd">             - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">               then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">               and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        - ``SO3.RPY(⍺, β, 𝛾)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY(0.1, 0.2, 0.3, order=&#39;xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY(10, 20, 30, unit=&quot;deg&quot;)</span>


<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.rpy`, :func:`~spatialmath.pose3d.SE3.RPY`, :func:`spatialmath.base.transforms3d.rpy2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># angles = base.getmatrix(angles, (None, 3))</span>
        <span class="c1"># return cls(base.rpy2r(angles, order=order, unit=unit), check=False)</span>

        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="SO3.OA"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.OA">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">OA</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from two vectors</span>

<span class="sd">        :param o: 3-vector parallel to Y- axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :param a: 3-vector parallel to the Z-axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.OA(O, A)`` is an SO(3) rotation defined in terms of</span>
<span class="sd">        vectors parallel to the Y- and Z-axes of its reference frame.  In robotics these axes are</span>
<span class="sd">        respectively called the *orientation* and *approach* vectors defined such that</span>
<span class="sd">        R = [N, O, A] and N = O x A.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Only the ``A`` vector is guaranteed to have the same direction in the resulting</span>
<span class="sd">            rotation matrix</span>
<span class="sd">            - ``O`` and ``A`` do not have to be unit-length, they are normalized</span>
<span class="sd">            - ``O`` and ``A` do not have to be orthogonal, so long as they are not parallel</span>

<span class="sd">        :seealso: :func:`spatialmath.base.transforms3d.oa2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">oa2r</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.TwoVectors"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.TwoVectors">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">TwoVectors</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike3</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike3</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike3</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from any two vectors</span>

<span class="sd">        :param x: new x-axis, defaults to None</span>
<span class="sd">        :type x: str, array_like(3), optional</span>
<span class="sd">        :param y: new y-axis, defaults to None</span>
<span class="sd">        :type y: str, array_like(3), optional</span>
<span class="sd">        :param z: new z-axis, defaults to None</span>
<span class="sd">        :type z: str, array_like(3), optional</span>

<span class="sd">        Create a rotation by defining the direction of two of the new</span>
<span class="sd">        axes in terms of the old axes.  Axes are denoted by strings ``&quot;x&quot;``,</span>
<span class="sd">        ``&quot;y&quot;``, ``&quot;z&quot;``, ``&quot;-x&quot;``, ``&quot;-y&quot;``, ``&quot;-z&quot;``.</span>

<span class="sd">        The directions can also be specified by 3-element vectors. If the vectors are not orthogonal,</span>
<span class="sd">        they will orthogonalized w.r.t. the first available dimension. I.e. if x is available, it will be</span>
<span class="sd">        normalized and the remaining vector will be orthogonalized w.r.t. x, else, y will be normalized</span>
<span class="sd">        and z will be orthogonalized w.r.t. y.</span>

<span class="sd">        To create a rotation where the new frame has its x-axis in -z-direction</span>
<span class="sd">        of the previous frame, and its z-axis in the x-direction of the previous</span>
<span class="sd">        frame is::</span>

<span class="sd">            &gt;&gt;&gt; SO3.TwoVectors(x=&#39;-z&#39;, z=&#39;x&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">vval</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># skip sign char</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># skip sign char</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only two vectors should be provided. Please set one to None.&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># z = x x y</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># Orthogonalizes y w.r.t. x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">orthogonalize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># x = y x z</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="c1"># Orthogonalizes z w.r.t. y</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">orthogonalize</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># y = z x x</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># Orthogonalizes z w.r.t. x</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">orthogonalize</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Insufficient number of vectors. Please provide exactly two vectors.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.RotatedVector"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.RotatedVector">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RotatedVector</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from a vector and its rotated image</span>

<span class="sd">        :param v1: initial vector</span>
<span class="sd">        :type v1: array_like(3)</span>
<span class="sd">        :param v2: vector after rotation</span>
<span class="sd">        :type v2: array_like(3)</span>
<span class="sd">        :param tol: tolerance for singularity in units of eps, defaults to 20</span>
<span class="sd">        :type tol: float</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: :class:`SO3` instance</span>

<span class="sd">        ``SO3.RotatedVector(v1, v2)`` is an SO(3) rotation defined in terms of</span>
<span class="sd">        two vectors. The rotation takes vector ``v1`` to ``v2``.</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; v1 = [1, 2, 3]</span>
<span class="sd">            &gt;&gt;&gt; v2 = SO3.Eul(0.3, 0.4, 0.5) * v1</span>
<span class="sd">            &gt;&gt;&gt; print(v2)</span>
<span class="sd">            &gt;&gt;&gt; R = SO3.RotatedVector(v1, v2)</span>
<span class="sd">            &gt;&gt;&gt; print(R)</span>
<span class="sd">            &gt;&gt;&gt; print(R * v1)</span>

<span class="sd">        .. note:: The vectors do not have to be unit-length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">V</span> <span class="o">+</span> <span class="n">V</span> <span class="o">@</span> <span class="n">V</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.AngleAxis"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.AngleAxis">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">AngleAxis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) rotation matrix from rotation angle and axis</span>

<span class="sd">        :param theta: rotation</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.AngleAxis(theta, V)`` is an SO(3) rotation defined by</span>
<span class="sd">        a rotation of ``THETA`` about the vector ``V``.</span>

<span class="sd">        .. note:: :math:`\theta \eq 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">angvec2r</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.AngVec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.AngVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">AngVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) rotation matrix from rotation angle and axis</span>

<span class="sd">        :param theta: rotation</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.AngVec(theta, V)`` is an SO(3) rotation defined by</span>
<span class="sd">        a rotation of ``THETA`` about the vector ``V``.</span>

<span class="sd">        .. deprecated:: 0.9.8</span>
<span class="sd">            Use :meth:`AngleAxis` instead.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">angvec2r</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.EulerVec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.EulerVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">EulerVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) rotation matrix from an Euler rotation vector</span>

<span class="sd">        :param ω: rotation axis</span>
<span class="sd">        :type ω: 3-element array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.EulerVec(ω)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of :math:`\theta = \lVert \omega \rVert` about the</span>
<span class="sd">        unit 3-vector :math:`\omega / \lVert \omega \rVert`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.EulerVec([0.5,0,0])</span>

<span class="sd">        .. note:: :math:`\theta \eq 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;w must be a 3-vector&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">angvec2r</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Exp"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Exp">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Exp</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">R3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">],</span>
        <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">so3</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SO(3) rotation matrix from so(3)</span>

<span class="sd">        :param S: Lie algebra so(3)</span>
<span class="sd">        :type S: ndarray(3,3), ndarray(n,3)</span>
<span class="sd">        :param check: check that passed matrix is valid so(3), default True</span>
<span class="sd">        :bool check: bool, optional</span>
<span class="sd">        :param so3: the input is interpretted as an so(3) matrix not a stack of three twists, default True</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Exp(S)`` is an SO(3) rotation defined by its Lie algebra</span>
<span class="sd">          which is a 3x3 so(3) matrix (skew symmetric)</span>
<span class="sd">        - ``SO3.Exp(t)`` is an SO(3) rotation defined by a 3-element twist</span>
<span class="sd">          vector (the unique elements of the so(3) skew-symmetric matrix)</span>
<span class="sd">        - ``SO3.Exp(T)`` is a sequence of SO(3) rotations defined by an Nx3 matrix</span>
<span class="sd">          of twist vectors, one per row.</span>

<span class="sd">        .. note::</span>
<span class="sd">        - if :math:`\theta \eq 0` the result in an identity matrix</span>
<span class="sd">        - an input 3x3 matrix is ambiguous, it could be the first or third case above.  In this</span>
<span class="sd">          case the parameter `so3` is the decider.</span>

<span class="sd">        :seealso: :func:`spatialmath.base.transforms3d.trexp`, :func:`spatialmath.base.transformsNd.skew`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">ismatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">so3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">R3</span><span class="p">,</span> <span class="n">S</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.UnitQuaternion"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.UnitQuaternion">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">UnitQuaternion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO3 as a unit quaternion instance</span>

<span class="sd">        :return: a unit quaternion representation</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``R.UnitQuaternion()`` is an ``UnitQuaternion`` instance representing the same rotation</span>
<span class="sd">        as the SO3 rotation ``R``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.Rz(0.3).UnitQuaternion()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Function level import to avoid circular dependencies</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnitQuaternion</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.angdist"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.angdist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">angdist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SO3</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angular distance metric between rotations</span>

<span class="sd">        :param other: second rotation</span>
<span class="sd">        :type other: SO3 instance</span>
<span class="sd">        :param metric: metric, default is 6</span>
<span class="sd">        :type metric: int</span>
<span class="sd">        :raises TypeError: if other is not an SO3</span>
<span class="sd">        :return: angle in radians</span>
<span class="sd">        :rtype: float or ndarray</span>

<span class="sd">        ``R1.angdist(R2)`` is the geodesic norm, or geodesic distance between two</span>
<span class="sd">        rotations.</span>

<span class="sd">        Several metrics are supported, the first 5 are computed after conversion</span>
<span class="sd">        to unit quaternions.</span>

<span class="sd">        ======   ===============================================================</span>
<span class="sd">        Metric   Details</span>
<span class="sd">        ======   ===============================================================</span>
<span class="sd">        0        :math:`1 - | \q_1 \bullet \q_2 | \in [0, 1]`</span>
<span class="sd">        1        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        2        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        3        :math:`2 \tan^{-1} \| \q_1 - \q_2\| / \|\q_1 + \q_2\| \in [0, \pi/2]`</span>
<span class="sd">        4        :math:`\cos^{-1} \left( 2 (\q_1 \bullet \q_2)^2 - 1\right) \in [0, 1]`</span>
<span class="sd">        5        :math:`\|I - \mat{R}_1 \mat{R}_2^T\| \in [0, 2]`</span>
<span class="sd">        6        :math:`\|\log \mat{R}_1 \mat{R}_2^T\| \in [0, \pi]`</span>
<span class="sd">        ======   ===============================================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; R1 = SO3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; R2 = SO3.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(R1.angdist(R1))</span>
<span class="sd">            &gt;&gt;&gt; print(R1.angdist(R2))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - metrics 1, 2, 4 can throw ValueError &quot;math domain error&quot; due to</span>
<span class="sd">              numeric errors which push the argument of ``acos()`` marginally</span>
<span class="sd">              outside its domain [0, 1].</span>
<span class="sd">            - metrics 2 and 3 are equivalent, but 3 is more robust</span>

<span class="sd">        :seealso: :func:`UnitQuaternion.angdist`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.quaternion</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnitQuaternion</span>

            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">angdist</span><span class="p">(</span><span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">:</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trlog</span><span class="p">(</span><span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown metric&quot;</span><span class="p">)</span>

        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op2</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ad</span></div>

<div class="viewcode-block" id="SO3.mean"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.mean">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SO3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of a set of rotations</span>

<span class="sd">        :param tol: iteration tolerance in units of eps, defaults to 20</span>
<span class="sd">        :type tol: float, optional</span>
<span class="sd">        :return: the mean rotation</span>
<span class="sd">        :rtype: :class:`SO3` instance.</span>

<span class="sd">        Computes the Karcher mean of the set of rotations within the SO(3) instance.</span>

<span class="sd">        :references:</span>
<span class="sd">            - `**Hartley, Trumpf** - &quot;Rotation Averaging&quot; - IJCV 2011 &lt;https://users.cecs.anu.edu.au/~hartley/Papers/PDF/Hartley-Trumpf:Rotation-averaging:IJCV.pdf&gt;`_, Algorithm 1, page 15.</span>
<span class="sd">            - `Karcher mean &lt;https://en.wikipedia.org/wiki/Karcher_mean&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">eta</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">R_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># initial guess</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">R_mean</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">log</span><span class="p">())</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eta</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">R_mean</span>
            <span class="n">R_mean</span> <span class="o">=</span> <span class="n">R_mean</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Exp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># update estimate and normalize</span></div></div>


<span class="c1"># ============================== SE3 =====================================#</span>


<div class="viewcode-block" id="SE3"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">SE3</span><span class="p">(</span><span class="n">SO3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       SE(3) matrix class</span>

<span class="sd">       This subclass represents rigid-body motion in 3D space.  Internally it is a</span>
<span class="sd">       4x4 homogeneous transformation matrix belonging to the group SE(3).</span>

<span class="sd">    .. inheritance-diagram:: spatialmath.pose3d.SE3</span>
<span class="sd">       :top-classes: collections.UserList</span>
<span class="sd">       :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># identity</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SE3</span><span class="p">,</span> <span class="n">SO3</span><span class="p">,</span> <span class="n">SE2</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># copy/promote</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SE3</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># import list of SE3</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pure translation</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pure translation</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">SE3Array</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># import native array</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SE3Array</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># import native arrays</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SE3.__init__"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct new SE(3) object</span>

<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        There are multiple call signatures that return an ``SE3`` instance</span>
<span class="sd">        with one or more values.</span>

<span class="sd">        - ``SE3()`` null motion, value is the identity matrix.</span>
<span class="sd">        - ``SE3(x, y, z)`` is a pure translation of (x,y,z)</span>
<span class="sd">        - ``SE3(T)``  where ``T`` is a 4x4 Numpy  array representing an SE(3)</span>
<span class="sd">          matrix.  If ``check`` is ``True`` check the matrix belongs to SE(3).</span>
<span class="sd">        - ``SE3([T1, T2, ... TN])`` has ``N`` values</span>
<span class="sd">          given by the elements ``Ti`` each of which is a 4x4 NumPy array</span>
<span class="sd">          representing an SE(3) matrix. If ``check`` is ``True`` check the</span>
<span class="sd">          matrix belongs to SE(3).</span>
<span class="sd">        - ``SE3(X)`` where ``X`` is:</span>
<span class="sd">          -  ``SE3`` is a copy of ``X``</span>
<span class="sd">          -  ``SO3`` is the rotation of ``X`` with zero translation</span>
<span class="sd">          -  ``SE2`` is the z-axis rotation and x- and y-axis translation of</span>
<span class="sd">             ``X``</span>
<span class="sd">        - ``SE3([X1, X2, ... XN])`` has ``N`` values</span>
<span class="sd">          given by the elements ``Xi`` each of which is an SE3 instance.</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># just one argument passed</span>

            <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SO3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">r2t</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SE2</span><span class="p">):</span>  <span class="c1"># type(x).__name__ == &quot;SE2&quot;:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">SE3</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>
            <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="c1"># SE3( [x, y, z] )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># SE3( Nx3 )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad argument to constructor&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># SE3(x, y, z)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid arguments. See documentation for correct format.&quot;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_identity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------ #</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the object&#39;s internal matrix representation</span>

<span class="sd">        :return: (4,4)</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        Each value within the ``SE3`` instance is a NumPy array of this shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="nd">@SO3</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">SO3Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only assign rotation to length 1 object&quot;</span><span class="p">)</span>
        <span class="n">so3</span> <span class="o">=</span> <span class="n">SO3</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">so3</span><span class="o">.</span><span class="n">R</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translational component of SE(3)</span>

<span class="sd">        :return: translational component of SE(3)</span>
<span class="sd">        :rtype: numpy.ndarray</span>

<span class="sd">        ``x.t`` is the translational component of ``x`` as an array with</span>
<span class="sd">        shape (3,). If ``len(x) &gt; 1``, return an array with shape=(N,3).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; x = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; x.t</span>
<span class="sd">            &gt;&gt;&gt; x = SE3([ SE3(1,2,3), SE3(4,5,6)])</span>
<span class="sd">            &gt;&gt;&gt; x.t</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

    <span class="nd">@t</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only assign translation to length 1 object&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First element of translational component of SE(3)</span>

<span class="sd">        :return: first element of translational component of SE(3)</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        If ``len(v) &gt; 1``, return an array with shape=(N,).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; v = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; v.x</span>
<span class="sd">            &gt;&gt;&gt; v = SE3([ SE3(1,2,3), SE3(4,5,6)])</span>
<span class="sd">            &gt;&gt;&gt; v.x</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only assign elements to length 1 object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Second element of translational component of SE(3)</span>

<span class="sd">        :return: second element of translational component of SE(3)</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        If ``len(v) &gt; 1``, return an array with shape=(N,).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; v = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; v.y</span>
<span class="sd">            &gt;&gt;&gt; v = SE3([ SE3(1,2,3), SE3(4,5,6)])</span>
<span class="sd">            &gt;&gt;&gt; v.y</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

    <span class="nd">@y</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only assign elements to length 1 object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Third element of translational component of SE(3)</span>

<span class="sd">        :return: third element of translational component of SE(3)</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        If ``len(v) &gt; 1``, return an array with shape=(N,).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; v = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; v.z</span>
<span class="sd">            &gt;&gt;&gt; v = SE3([ SE3(1,2,3), SE3(4,5,6)])</span>
<span class="sd">            &gt;&gt;&gt; v.z</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

    <span class="nd">@z</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only assign elements to length 1 object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>

    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SE3.inv"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.inv">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of SE(3)</span>

<span class="sd">        :return: inverse</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        Efficiently compute the inverse of each of the SE(3) values taking into</span>
<span class="sd">        account the matrix structure.</span>

<span class="sd">        .. math::</span>

<span class="sd">            T = \left[ \begin{array}{cc} \mat{R} &amp; \vec{t} \\ 0 &amp; 1 \end{array} \right],</span>
<span class="sd">            \mat{T}^{-1} = \left[ \begin{array}{cc} \mat{R}^T &amp; -\mat{R}^T \vec{t} \\ 0 &amp; 1 \end{array} \right]`</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; x = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; x.inv()</span>


<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trinv`</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SE3</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SE3</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">trinv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.yaw_SE2"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.yaw_SE2">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">yaw_SE2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE2</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create SE(2) from SE(3) yaw angle.</span>

<span class="sd">        :param order: angle sequence order, default to &#39;zyx&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :return: SE(2) with same rotation as the yaw angle using the roll-pitch-yaw convention,</span>
<span class="sd">            and translation along the roll-pitch axes.</span>
<span class="sd">        :rtype: SE2 instance</span>

<span class="sd">        Roll-pitch-yaw corresponds to successive rotations about the axes specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;zyx&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SE2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SE2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;yxz&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SE2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SE2</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">yaw_SE2</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="SE3.delta"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.delta">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SE3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R6</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infinitesimal difference of SE(3) values</span>

<span class="sd">        :return: differential motion vector</span>
<span class="sd">        :rtype: ndarray(6)</span>

<span class="sd">        ``X1.delta(X2)`` is the differential motion (6x1) corresponding to</span>
<span class="sd">        infinitesimal motion (in the ``X1`` frame) from pose ``X1`` to ``X2``.</span>

<span class="sd">        The vector :math:`d = [\delta_x, \delta_y, \delta_z, \theta_x, \theta_y, \theta_z]`</span>
<span class="sd">        represents infinitesimal translation and rotation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; x1 = SE3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; x2 = SE3.Rx(0.3001)</span>
<span class="sd">            &gt;&gt;&gt; x1.delta(x2)</span>

<span class="sd">        .. note::</span>

<span class="sd">            - the displacement is only an approximation to the motion, and assumes</span>
<span class="sd">              that ``X1`` ~ ``X2``.</span>
<span class="sd">            - can be considered as an approximation to the effect of spatial velocity over a</span>
<span class="sd">              a time interval, ie. the average spatial velocity multiplied by time.</span>

<span class="sd">        :Reference: Robotics, Vision &amp; Control for Python, Section 3.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.tr2delta`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">X2</span><span class="o">.</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.rtvec"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.rtvec">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rtvec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">R3</span><span class="p">,</span> <span class="n">R3</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to OpenCV-style rotation and translation vectors</span>

<span class="sd">        :return: rotation and translation vectors</span>
<span class="sd">        :rtype: ndarray(3), ndarray(3)</span>

<span class="sd">        Many OpenCV functions accept pose as two 3-vectors: a rotation vector using</span>
<span class="sd">        exponential coordinates and a translation vector.  This method combines them</span>
<span class="sd">        into an SE(3) instance.</span>

<span class="sd">        :seealso: :meth:`rtvec`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SO3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span></div>

<div class="viewcode-block" id="SE3.Ad"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Ad">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">Ad</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R6x6</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjoint of SE(3)</span>

<span class="sd">        :return: adjoint matrix</span>
<span class="sd">        :rtype: ndarray(6,6)</span>

<span class="sd">        ``SE3.Ad`` is the 6x6 adjoint matrix</span>

<span class="sd">        If spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        and the SE(3) represents the pose of {B} relative to {A},</span>
<span class="sd">        ie. :math:`{}^A {\bf T}_B`, and the adjoint is :math:`\mathbf{A}` then</span>
<span class="sd">        :math:`{}^{A}\!\nu = \mathbf{A} {}^{B}\!\nu`.</span>

<span class="sd">        .. warning:: Do not use this method to map velocities</span>
<span class="sd">            between robot base and end-effector frames - use ``jacob()``.</span>

<span class="sd">        .. note:: Use this method to map velocities between two frames on</span>
<span class="sd">            the same rigid-body.</span>

<span class="sd">        :Reference: Robotics, Vision &amp; Control for Python, Section 3.1, P. Corke, Springer 2023.</span>
<span class="sd">        :seealso: SE3.jacob, Twist.ad, :func:`~spatialmath.base.tr2jac`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2adjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.jacob"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.jacob">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">jacob</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R6x6</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Velocity transform for SE(3)</span>

<span class="sd">        :return: Jacobian matrix</span>
<span class="sd">        :rtype: ndarray(6,6)</span>

<span class="sd">        ``SE3.jacob()`` is the 6x6 Jacobian that maps spatial velocity or</span>
<span class="sd">        differential motion from frame {B} to frame {A} where the pose of {B}</span>
<span class="sd">        relative to {A} is represented by the homogeneous transform T =</span>
<span class="sd">        :math:`{}^A {\bf T}_B`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            - To map from frame {A} to frame {B} use the transpose of this matrix.</span>
<span class="sd">            - Use this method to map velocities between the robot end-effector frame</span>
<span class="sd">              and the base frames.</span>

<span class="sd">        .. warning:: Do not use this method to map velocities between two frames</span>
<span class="sd">            on the same rigid-body.</span>

<span class="sd">        :seealso: SE3.Ad, Twist.ad, :func:`~spatialmath.base.tr2jac`</span>
<span class="sd">        :Reference: Robotics, Vision &amp; Control for Python, Section 3.1, P. Corke, Springer 2023.</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2jac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.twist"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.twist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">twist</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Twist3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SE(3) as twist</span>

<span class="sd">        :return: equivalent rigid-body motion as a twist vector</span>
<span class="sd">        :rtype: Twist3 instance</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; x = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; x.twist()</span>

<span class="sd">        :seealso: :func:`spatialmath.twist.Twist3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Twist3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>

    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SE3.isvalid"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if matrix is a valid SE(3)</span>

<span class="sd">        :param x: matrix to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :return: ``True`` if the matrix is 4x4 and a valid element of SE(3), ie. it</span>
<span class="sd">                 is a valid homogeneous transformation matrix.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.ishom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">ishom</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span></div>

    <span class="c1"># ---------------- variant constructors ---------------------------------- #</span>

<div class="viewcode-block" id="SE3.Rx"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rx</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span>
        <span class="n">t</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create anSE(3) pure rotation about the X-axis</span>

<span class="sd">        :param θ: rotation angle about X-axis</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param t: translation, optional</span>
<span class="sd">        :type t: 3-element array-like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Rx(θ)`` is an SE(3) rotation of θ radians about the x-axis</span>
<span class="sd">        - ``SE3.Rx(θ, &quot;deg&quot;)`` as above but θ is in degrees</span>
<span class="sd">        - ``SE3.Rx(θ, t=T)`` as above but also sets the translational component</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined</span>
<span class="sd">        by consecutive elements.</span>

<span class="sd">        .. note:: The translation option only works for the scalar θ case.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rx([0.3, 0.4])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trotx`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">trotx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Ry"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Ry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Ry</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span>
        <span class="n">t</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation about the Y-axis</span>

<span class="sd">        :param θ: rotation angle about X-axis</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param t: translation, optional</span>
<span class="sd">        :type t: 3-element array-like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Ry(θ)`` is an SO(3) rotation of θ radians about the y-axis</span>
<span class="sd">        - ``SE3.Ry(θ, &quot;deg&quot;)`` as above but θ is in degrees</span>
<span class="sd">        - ``SE3.Ry(θ, t=T)`` as above but also sets the translational component</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined</span>
<span class="sd">        by consecutive elements.</span>

<span class="sd">        .. note:: The translation option only works for the scalar θ case.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Ry([0.3, 0.4])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.troty`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">troty</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Rz"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rz</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span>
        <span class="n">t</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation about the Z-axis</span>

<span class="sd">        :param θ: rotation angle about Z-axis</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param t: translation, optional</span>
<span class="sd">        :type t: 3-element array-like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Rz(θ)`` is an SO(3) rotation of θ radians about the z-axis</span>
<span class="sd">        - ``SE3.Rz(θ, &quot;deg&quot;)`` as above but θ is in degrees</span>
<span class="sd">        - ``SE3.Rz(θ, t=T)`` as above but also sets the translational component</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined</span>
<span class="sd">        by consecutive elements.</span>

<span class="sd">        .. note:: The translation option only works for the scalar θ case.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rz(0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rz([0.3, 0.4])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trotz`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">trotz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Rand"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rand">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rand</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">xrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">yrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">zrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">theta_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>  <span class="c1"># pylint: disable=arguments-differ</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a random SE(3)</span>

<span class="sd">        :param xrange: x-axis range [min,max], defaults to [-1, 1]</span>
<span class="sd">        :type xrange: 2-element sequence, optional</span>
<span class="sd">        :param yrange: y-axis range [min,max], defaults to [-1, 1]</span>
<span class="sd">        :type yrange: 2-element sequence, optional</span>
<span class="sd">        :param zrange: z-axis range [min,max], defaults to [-1, 1]</span>
<span class="sd">        :type zrange: 2-element sequence, optional</span>
<span class="sd">        :param theta_range: angular magnitude range [min,max], defaults to None -&gt; [0,pi].</span>
<span class="sd">        :type xrange: 2-element sequence, optional</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param N: number of random transforms</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        Return an SE3 instance with random rotation and translation.</span>

<span class="sd">        - ``SE3.Rand()`` is a random SE(3) translation.</span>
<span class="sd">        - ``SE3.Rand(N)`` is an SE3 object containing a sequence of N random</span>
<span class="sd">          poses.</span>


<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rand(2)</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternions.UnitQuaternion.Rand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span>
        <span class="p">)</span>  <span class="c1"># random values in the range</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=</span><span class="n">yrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">yrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span>
        <span class="p">)</span>  <span class="c1"># random values in the range</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=</span><span class="n">zrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">zrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span>
        <span class="p">)</span>  <span class="c1"># random values in the range</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">SO3</span><span class="o">.</span><span class="n">Rand</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">theta_range</span><span class="o">=</span><span class="n">theta_range</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">@</span> <span class="n">smb</span><span class="o">.</span><span class="n">r2t</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">)],</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">psi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SE3.Eul"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Eul">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation from Euler angles</span>

<span class="sd">        :param 𝚪: Euler angles</span>
<span class="sd">        :type 𝚪: 3 floats, array_like(3) or ndarray(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Eul(𝚪)`` is an SE(3) rotation defined by a 3-vector of Euler</span>
<span class="sd">          angles :math:`\Gamma=(\phi, \theta, \psi)` which correspond to</span>
<span class="sd">          consecutive rotations about the Z, Y, Z axes respectively.</span>

<span class="sd">        If ``𝚪`` is an Nx3 matrix then the result is a sequence of</span>
<span class="sd">        rotations each defined by Euler angles corresponding to the rows of</span>
<span class="sd">        ``𝚪``.</span>

<span class="sd">        - ``SE3.Eul(φ, θ, ψ)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Eul(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Eul([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SE3.Eul(10, 20, 30, unit=&quot;deg&quot;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.eul`, :func:`~spatialmath.base.transforms3d.eul2r`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">eul2tr</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">eul2tr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">roll</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">pitch</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">yaw</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SE3.RPY"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.RPY">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;rad&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;zyx&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation from roll-pitch-yaw angles</span>

<span class="sd">        :param 𝚪: roll-pitch-yaw angles</span>
<span class="sd">        :type 𝚪: 3 floats, array_like(3) or ndarray(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param order: rotation order: &#39;zyx&#39; [default], &#39;xyz&#39;, or &#39;yxz&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.RPY(𝚪)`` is an SE(3) rotation defined by a 3-vector of roll,</span>
<span class="sd">          pitch, yaw angles :math:`\Gamma=(r, p, y)` which correspond to</span>
<span class="sd">          successive rotations about the axes specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  This is the **convention** for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. This is the **convention** for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. This is the **convention** for a camera with z-axis parallel</span>
<span class="sd">              to the optical axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        If ``𝚪`` is an Nx3 matrix then the result is a sequence of rotations each defined by RPY angles</span>
<span class="sd">        corresponding to the rows of ``𝚪``.</span>

<span class="sd">        - ``SE3.RPY(⍺, β, 𝛾)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY(0.1, 0.2, 0.3, order=&#39;xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY(10, 20, 30, unit=&#39;deg&#39;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.rpy`, :func:`~spatialmath.base.transforms3d.rpy2r`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">rpy2tr</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">rpy2tr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="SE3.OA"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.OA">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">OA</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation from two vectors</span>

<span class="sd">        :param o: 3-vector parallel to Y- axis</span>
<span class="sd">        :type o: array_like(3)</span>
<span class="sd">        :param a: 3-vector parallel to the Z-axis</span>
<span class="sd">        :type a: array_like(3)</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.OA(o, a)`` is an SE(3) rotation defined in terms of vectors ``o``</span>
<span class="sd">        and ``a`` respectively parallel to the Y- and Z-axes of its reference</span>
<span class="sd">        frame.  In robotics these axes are respectively called the *orientation*</span>
<span class="sd">        and *approach* vectors defined such that :math:`\mathbf{R} = [n, o, a]`</span>
<span class="sd">        and :math:`n = o \times a`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The ``a`` vector is the only guaranteed to have the same direction in the resulting</span>
<span class="sd">              rotation matrix</span>
<span class="sd">            - ``o`` and ``a`` do not have to be unit-length, they are normalized</span>
<span class="sd">            - ``o`` and ``a`` do not have to be orthogonal, so long as they are not parallel</span>
<span class="sd">              ``o`` is adjusted to be orthogonal to ``a``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.OA([1, 0, 0], [0, 0, -1])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.oa2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">oa2tr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.AngleAxis"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.AngleAxis">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">AngleAxis</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation matrix from rotation angle and axis</span>

<span class="sd">        :param θ: rotation</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis</span>
<span class="sd">        :type v: array_like(3)</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.AngleAxis(θ, v)`` is an SE(3) rotation defined by</span>
<span class="sd">        a rotation of ``θ`` about the vector ``v``.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mbox{if}\,\, \theta \left\{ \begin{array}{ll}</span>
<span class="sd">                = 0 &amp; \mbox{return identity matrix}\\</span>
<span class="sd">                \ne 0 &amp; \mbox{v must have a finite length}</span>
<span class="sd">                \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.pose3d.SE3.EulerVec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">angvec2tr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.AngVec"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.AngVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">AngVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation matrix from rotation angle and axis</span>

<span class="sd">        :param θ: rotation</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis</span>
<span class="sd">        :type v: array_like(3)</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.AngVec(θ, v)`` is an SE(3) rotation defined by</span>
<span class="sd">        a rotation of ``θ`` about the vector ``v``.</span>

<span class="sd">        .. deprecated:: 0.9.8</span>
<span class="sd">            Use :meth:`AngleAxis` instead.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.pose3d.SE3.EulerVec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">angvec2tr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.EulerVec"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.EulerVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">EulerVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SE(3) pure rotation matrix from an Euler rotation vector</span>

<span class="sd">        :param ω: rotation axis</span>
<span class="sd">        :type ω: array_like(3)</span>
<span class="sd">        :return: SE(3) rotation</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.EulerVec(ω)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of :math:`\theta = \lVert \omega \rVert` about the</span>
<span class="sd">        unit 3-vector :math:`\omega / \lVert \omega \rVert`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.EulerVec([0.5,0,0])</span>

<span class="sd">        .. note:: :math:`\theta = 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.AngVec`, :func:`~spatialmath.base.transforms3d.angvec2tr`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;w must be a 3-vector&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">angvec2tr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Exp"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Exp">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Exp</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">R6</span><span class="p">,</span> <span class="n">R4x4</span><span class="p">],</span> <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) matrix from se(3)</span>

<span class="sd">        :param S: Lie algebra se(3) matrix</span>
<span class="sd">        :type S: ndarray(6), ndarray(4,4)</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Exp(S)`` is an SE(3) rotation defined by its Lie algebra</span>
<span class="sd">          which is a 4x4 se(3) matrix (skew symmetric)</span>
<span class="sd">        - ``SE3.Exp(t)`` is an SE(3) rotation defined by a 6-element twist</span>
<span class="sd">          vector (the unique elements of the se(3) skew-symmetric matrix)</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trexp`, :func:`~spatialmath.base.transformsNd.skew`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">S</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.RTvec"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.RTvec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RTvec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rvec</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">tvec</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SE(3) from OpenCV-style rotation and translation vectors</span>

<span class="sd">        :param rvec: rotation as exponential coordinates</span>
<span class="sd">        :type rvec: ArrayLike3</span>
<span class="sd">        :param tvec: translation vector</span>
<span class="sd">        :type tvec: ArrayLike3</span>
<span class="sd">        :return: An SE(3) instance</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        Many OpenCV functions (such as pose estimation) return pose as two 3-vectors: a</span>
<span class="sd">        rotation vector using exponential coordinates and a translation vector.  This</span>
<span class="sd">        method combines them into an SE(3) instance.</span>

<span class="sd">        :seealso: :meth:`rtvec`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Rt</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">rvec</span><span class="p">),</span> <span class="n">tvec</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Delta"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Delta">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Delta</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">ArrayLike6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create SE(3) from differential motion</span>

<span class="sd">        :param d: differential motion</span>
<span class="sd">        :type d: array_like(6)</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.Delta2tr(d)`` is an SE(3) representing differential</span>
<span class="sd">        motion :math:`d = [\delta_x, \delta_y, \delta_z, \theta_x, \theta_y, \theta_z]`.</span>

<span class="sd">        :Reference: Robotics, Vision &amp; Control for Python, Section 3.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`~delta` :func:`~spatialmath.base.transform3d.delta2tr`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">trnorm</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">delta2tr</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span></div>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Trans</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Trans</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="SE3.Trans"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Trans">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Trans</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create SE(3) from translation vector</span>

<span class="sd">        :param x: x-coordinate or translation vector</span>
<span class="sd">        :type x: float or array_like(3)</span>
<span class="sd">        :param y: y-coordinate, defaults to None</span>
<span class="sd">        :type y: float, optional</span>
<span class="sd">        :param z: z-coordinate, defaults to None</span>
<span class="sd">        :type z: float, optional</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Trans(x, y, z)`` is an SE(3) representing pure translation.</span>

<span class="sd">        - ``SE3.Trans([x, y, z])`` as above, but translation is given as an</span>
<span class="sd">          array.</span>

<span class="sd">        - ``SE3.Trans(t)`` where ``t`` is Nx3 then create an SE3 object with</span>
<span class="sd">          N elements whose translation is defined by the rows of ``t``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># single passed value, assume is 3-vector or Nx3</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">_t</span><span class="p">)</span> <span class="k">for</span> <span class="n">_t</span> <span class="ow">in</span> <span class="n">t</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]))</span></div>

<div class="viewcode-block" id="SE3.Tx"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Tx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Tx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) translation along the X-axis</span>

<span class="sd">        :param x: translation distance along the X-axis</span>
<span class="sd">        :type x: float</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        `SE3.Tx(x)` is an SE(3) translation of ``x`` along the x-axis</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Tx(2)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Tx([2,3])</span>


<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.transl`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Ty"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Ty">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Ty</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) translation along the Y-axis</span>

<span class="sd">        :param y: translation distance along the Y-axis</span>
<span class="sd">        :type y: float</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        `SE3.Ty(y) is an SE(3) translation of ``y`` along the y-axis</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Ty(2)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Ty([2,3])</span>


<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.transl`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_y</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Tz"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Tz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Tz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) translation along the Z-axis</span>

<span class="sd">        :param z: translation distance along the Z-axis</span>
<span class="sd">        :type z: float</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        `SE3.Tz(z)` is an SE(3) translation of ``z`` along the z-axis</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Tz(2)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Tz([2,3])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.transl`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_z</span><span class="p">)</span> <span class="k">for</span> <span class="n">_z</span> <span class="ow">in</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">z</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Rt"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rt">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rt</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SO3</span><span class="p">,</span> <span class="n">SO3Array</span><span class="p">],</span>
        <span class="n">t</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) from rotation and translation</span>

<span class="sd">        :param R: rotation</span>
<span class="sd">        :type R: SO3 or ndarray(3,3)</span>
<span class="sd">        :param t: translation</span>
<span class="sd">        :type t: array_like(3)</span>
<span class="sd">        :param check: check rotation validity, defaults to True</span>
<span class="sd">        :type check: bool, optional</span>
<span class="sd">        :raises ValueError: bad rotation matrix</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">SO3</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span>
        <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting SO3 or rotation matrix&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">rt2tr</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.CopyFrom"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.CopyFrom">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">CopyFrom</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">SE3Array</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) from a 4x4 numpy array that is passed by value.</span>

<span class="sd">        :param T: homogeneous transformation</span>
<span class="sd">        :type T: ndarray(4, 4)</span>
<span class="sd">        :param check: check rotation validity, defaults to True</span>
<span class="sd">        :type check: bool, optional</span>
<span class="sd">        :raises ValueError: bad rotation matrix, bad transformation matrix</span>
<span class="sd">        :return: SE(3) matrix representing that transformation</span>
<span class="sd">        :rtype: SE3 instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transformation matrix must not be None&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.angdist"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.angdist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">angdist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SE3</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angular distance metric between poses</span>

<span class="sd">        :param other: second rotation</span>
<span class="sd">        :type other: SE3 instance</span>
<span class="sd">        :param metric: metric, default is 6</span>
<span class="sd">        :type metric: int</span>
<span class="sd">        :raises TypeError: if other is not an SE3</span>
<span class="sd">        :return: angle in radians</span>
<span class="sd">        :rtype: float or ndarray</span>

<span class="sd">        ``T1.angdist(T2)`` is the geodesic norm, or geodesic distance between the</span>
<span class="sd">        rotational parts of the two poses.</span>

<span class="sd">        Several metrics are supported, the first 5 are computed after conversion</span>
<span class="sd">        to unit quaternions.</span>

<span class="sd">        ======   ===============================================================</span>
<span class="sd">        Metric   Details</span>
<span class="sd">        ======   ===============================================================</span>
<span class="sd">        0        :math:`1 - | \q_1 \bullet \q_2 | \in [0, 1]`</span>
<span class="sd">        1        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        2        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        3        :math:`2 \tan^{-1} \| \q_1 - \q_2\| / \|\q_1 + \q_2\| \in [0, \pi/2]`</span>
<span class="sd">        4        :math:`\cos^{-1} \left( 2 (\q_1 \bullet \q_2)^2 - 1\right) \in [0, 1]`</span>
<span class="sd">        5        :math:`\|I - \mat{R}_1 \mat{R}_2^T\| \in [0, 2]`</span>
<span class="sd">        6        :math:`\|\log \mat{R}_1 \mat{R}_2^T\| \in [0, \pi]`</span>
<span class="sd">        ======   ===============================================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; T1 = SE3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; T2 = SE3.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(T1.angdist(T1))</span>
<span class="sd">            &gt;&gt;&gt; print(T1.angdist(T2))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - metrics 1, 2, 4 can throw ValueError &quot;math domain error&quot; due to</span>
<span class="sd">              numeric errors which push the argument of ``acos()`` marginally</span>
<span class="sd">              outside its domain [0, 1].</span>
<span class="sd">            - metrics 2 and 3 are equivalent, but 3 is more robust</span>

<span class="sd">        :seealso: :func:`UnitQuaternion.angdist`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.quaternion</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnitQuaternion</span>

            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">angdist</span><span class="p">(</span><span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">T1</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">T2</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">:</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">smb</span><span class="o">.</span><span class="n">trlog</span><span class="p">(</span><span class="n">T1</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">T2</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown metric&quot;</span><span class="p">)</span>

        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op2</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ad</span></div></div>

    <span class="c1"># @classmethod</span>
    <span class="c1"># def SO3(cls, R, t=None, check=True):</span>
    <span class="c1">#     if isinstance(R, SO3):</span>
    <span class="c1">#         R = R.A</span>
    <span class="c1">#     elif base.isrot(R, check=check):</span>
    <span class="c1">#         pass</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         raise ValueError(&#39;expecting SO3 or rotation matrix&#39;)</span>
    <span class="c1">#     if t is None:</span>
    <span class="c1">#         return cls(base.r2t(R))</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return cls(base.rt2tr(R, t))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>

    <span class="n">exec</span><span class="p">(</span>
        <span class="nb">open</span><span class="p">(</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;tests&quot;</span> <span class="o">/</span> <span class="s2">&quot;test_pose3d.py&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>  <span class="c1"># pylint: disable=exec-used</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-, Peter Corke..
      <span class="lastupdated">Last updated on 30-Jan-2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>