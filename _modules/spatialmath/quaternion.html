

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spatialmath.quaternion &mdash; Spatial Maths package  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Spatial Maths package
              <img src="../../_static/CartesianSnakes_LogoW.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spatialmath.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indices.html">Indices</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Spatial Maths package</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spatialmath.quaternion</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spatialmath.quaternion</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes to abstract quaternions and unit-quaternions.</span>

<span class="sd">To use::</span>

<span class="sd">    from spatialmath.quaternion import *</span>
<span class="sd">    T = UnitQuaternion.Rx(0.3)</span>

<span class="sd">    import spatialmath as sm</span>
<span class="sd">    T = sm.UnitQuaternion.Rx(0.3)</span>

<span class="sd"> .. inheritance-diagram:: spatialmath.quaternion</span>
<span class="sd">    :top-classes: collections.UserList</span>
<span class="sd">    :parts: 1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=invalid-name</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">spatialmath.base</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">smb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.pose3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">SO3</span><span class="p">,</span> <span class="n">SE3</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.baseposelist</span><span class="w"> </span><span class="kn">import</span> <span class="n">BasePoseList</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">spatialmath.base.types</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="n">_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


<div class="viewcode-block" id="Quaternion"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">Quaternion</span><span class="p">(</span><span class="n">BasePoseList</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion class</span>

<span class="sd">    A quaternion can be considered an ordered pair :math:`(s, \vec{v})`</span>
<span class="sd">    where :math:`s \in \mathbb{R}` is the *scalar* part and :math:`\vec{v} = (v_x, v_y, v_z) \in \mathbb{R}^3`</span>
<span class="sd">    is the *vector* part and is often written as</span>

<span class="sd">    .. math:: \q = s \langle v_x, v_y, v_z \rangle</span>

<span class="sd">    .. inheritance-diagram:: spatialmath.quaternion.Quaternion</span>
<span class="sd">       :top-classes: collections.UserList</span>
<span class="sd">       :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quaternion.__init__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new quaternion</span>

<span class="sd">        :param s: scalar part</span>
<span class="sd">        :type s: float or ndarray(N)</span>
<span class="sd">        :param v: vector part</span>
<span class="sd">        :type v: ndarray(3), ndarray(Nx3)</span>

<span class="sd">        - ``Quaternion()`` constructs a zero quaternion</span>
<span class="sd">        - ``Quaternion(s, v)`` construct a new quaternion from the scalar ``s``</span>
<span class="sd">          and the vector ``v``</span>
<span class="sd">        - ``Quaternion(q)`` construct a new quaternion from the 4-vector</span>
<span class="sd">          ``q = [s, v]``</span>
<span class="sd">        - ``Quaternion([q1, q2 .. qN])`` construct a new quaternion with ``N``</span>
<span class="sd">          values where each element is a 4-vector</span>
<span class="sd">        - ``Quaternion([Q1, Q2 .. QN])`` construct a new quaternion with ``N``</span>
<span class="sd">          values where each element is a Quaternion instance</span>
<span class="sd">        - ``Quaternion(M)`` construct a new quaternion with ``N`` values where</span>
<span class="sd">          ``Q`` is a 4xN NumPy array.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion()</span>
<span class="sd">            &gt;&gt;&gt; Quaternion(1, [2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q=Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            &gt;&gt;&gt; len(q)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># single argument</span>
            <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Quaternion(s, v)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">)]]</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">smb</span><span class="o">.</span><span class="n">ismatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># Quaternion(s, v) where s and v are arrays</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">_s</span><span class="p">,</span> <span class="n">_v</span><span class="p">]</span> <span class="k">for</span> <span class="n">_s</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad argument to Quaternion constructor&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.Pure"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.Pure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Pure</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a pure quaternion from a vector</span>

<span class="sd">        :param v: vector</span>
<span class="sd">        :type v: 3-element array_like</span>

<span class="sd">        ``Quaternion.Pure(v)`` is a Quaternion with a zero scalar part and the</span>
<span class="sd">        vector part set to ``v``,</span>
<span class="sd">        ie. :math:`q = 0 \langle v_x, v_y, v_z \rangle`</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion.Pure([1,2,3]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_identity</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the object&#39;s interal matrix representation</span>

<span class="sd">        :return: (4,)</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span>

<div class="viewcode-block" id="Quaternion.isvalid"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vector is valid quaternion</span>

<span class="sd">        :param x: vector to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :arg check: explicitly check vector is unit length [default True]</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: True if the matrix has shape (4,).</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; Quaternion.isvalid(np.r_[1, 0, 0, 0])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion.isvalid(np.r_[1, 2, 3, 4])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scalar part of quaternion</span>

<span class="sd">        :return: scalar part of quaternion</span>
<span class="sd">        :rtype: float or numpy.ndarray</span>

<span class="sd">        ``q.s`` is the scalar part.  If `len(q)` is:</span>

<span class="sd">            - 1, return a scalar float</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,) is returned.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).s</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">s</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Vector part of quaternion</span>

<span class="sd">        :return: vector part of quaternion</span>
<span class="sd">        :rtype: NumPy ndarray</span>

<span class="sd">        ``q.v`` is the vector part.  If `len(q)` is:</span>

<span class="sd">            - 1, return a NumPy array shape=(3,)</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,3).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).v</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).v</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">v</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R4</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quaternion as a vector</span>

<span class="sd">        :return: quaternion expressed as a 4-vector</span>
<span class="sd">        :rtype: numpy ndarray, shape=(4,)</span>

<span class="sd">        ``q.vec`` is the quaternion as a vector.  If `len(q)` is:</span>

<span class="sd">            - 1, return a NumPy array shape=(4,)</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,4).</span>

<span class="sd">        The quaternion coefficients are in the order (s, vx, vy, vz), ie. with</span>
<span class="sd">        the scalar (real part) first.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).vec</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).vec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vec_xyzs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R4</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quaternion as a vector</span>

<span class="sd">        :return: quaternion expressed as a 4-vector</span>
<span class="sd">        :rtype: numpy ndarray, shape=(4,)</span>

<span class="sd">        ``q.vec_xyzs`` is the quaternion as a vector.  If `len(q)` is:</span>

<span class="sd">            - 1, return a NumPy array shape=(4,)</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,4).</span>

<span class="sd">        The quaternion coefficients are in the order (vx, vy, vz, s), ie. with</span>
<span class="sd">        the scalar (real part) last. This is useful when exporting to other</span>
<span class="sd">        packages like three.js or pybullet.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).vec_xyzs</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).vec_xyzs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R4x4</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix equivalent of quaternion</span>

<span class="sd">        :rtype: Numpy array, shape=(4,4)</span>

<span class="sd">        ``q.matrix`` is a 4x4 matrix which encodes the arithmetic rules of Hamilton multiplication.</span>
<span class="sd">        This matrix, multiplied by the 4-vector equivalent of a second quaternion, results in the 4-vector</span>
<span class="sd">        equivalent of the Hamilton product.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).matrix</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * Quaternion([5,6,7,8])   # Hamilton product</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).matrix @ Quaternion([5,6,7,8]).vec  # matrix-vector product</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qmatrix`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">qmatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

<div class="viewcode-block" id="Quaternion.conj"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.conj">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conjugate of quaternion</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q.conj()`` is the quaternion ``q`` with the vector part negated, ie.</span>
<span class="sd">        :math:`q = s \langle -v_x, -v_y, -v_z \rangle`</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion.Pure([1,2,3]).conj())</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qconj`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qconj</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="Quaternion.norm"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.norm">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Norm of quaternion</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        ``q.norm()`` is the norm or length of the quaternion</span>
<span class="sd">        :math:`\sqrt{s^2 + v_x^2 + v_y^2 + v_z^2}`</span>


<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).norm()</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).norm()</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qnorm`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">qnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qnorm</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="Quaternion.unit"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.unit">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion</span>

<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``q.unit()`` is the quaternion ``q`` normalized to have a unit length.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; print(q.unit())</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).unit())</span>

<span class="sd">        Note that the return type is different, a ``UnitQuaternion``, which is</span>
<span class="sd">        distinguished by the use of double angle brackets to delimit the</span>
<span class="sd">        vector part.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qnorm`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.log"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.log">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logarithm of quaternion</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q.log()`` is the logarithm of the quaternion ``q``, ie.</span>

<span class="sd">        .. math::</span>

<span class="sd">             \ln \| q \|,  \langle \frac{\vec{v}}{\| \vec{v} \|} \cos^{-1} \frac{s}{\| q \|} \rangle</span>

<span class="sd">        For a ``UnitQuaternion`` the logarithm is a pure quaternion whose vector</span>
<span class="sd">        part :math:`\vec{v}` and :math:`\vec{v}/2` is a Euler vector: parallel</span>
<span class="sd">        to the axis of rotation and whose norm is the magnitude of rotation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion, UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; from math import pi</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1, 2, 3, 4])</span>
<span class="sd">            &gt;&gt;&gt; print(q.log())</span>
<span class="sd">            &gt;&gt;&gt; q = UnitQuaternion.Rx(pi / 2)</span>
<span class="sd">            &gt;&gt;&gt; print(q.log())</span>

<span class="sd">        :reference: `Wikipedia &lt;https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions&gt;`_</span>

<span class="sd">        :seealso: :meth:`Quaternion.exp` :meth:`Quaternion.log` :meth:`UnitQuaternion.angvec`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">iszerovec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
                <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">iszerovec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
                <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

<div class="viewcode-block" id="Quaternion.exp"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.exp">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exponential of quaternion</span>

<span class="sd">        :param tol: Tolerance when checking for pure quaternion, in multiples of eps, defaults to 20</span>
<span class="sd">        :type tol: float, optional</span>
<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q.exp()`` is the exponential of the quaternion ``q``, ie.</span>

<span class="sd">        .. math::</span>

<span class="sd">             e^s \cos \| v \|,  \langle e^s \frac{\vec{v}}{\| \vec{v} \|} \sin \| \vec{v} \| \rangle</span>

<span class="sd">        For a pure quaternion with vector value :math:`\vec{v}` the the result</span>
<span class="sd">        is a unit quaternion equivalent to a rotation defined by</span>
<span class="sd">        :math:`2\vec{v}` intepretted as an Euler vector, that is, parallel to</span>
<span class="sd">        the axis of rotation and whose norm is the magnitude of rotation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; from math import pi</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1, 2, 3, 4])</span>
<span class="sd">            &gt;&gt;&gt; print(q.exp())</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion.Pure([pi / 4, 0, 0])</span>
<span class="sd">            &gt;&gt;&gt; print(q.exp())  # result is a UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; print(q.exp().angvec())</span>

<span class="sd">        :reference: `Wikipedia &lt;https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions&gt;`_</span>

<span class="sd">        :seealso: :meth:`Quaternion.log` :meth:`UnitQuaternion.log` :meth:`UnitQuaternion.AngVec` :meth:`UnitQuaternion.EulerVec`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exp_s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="n">norm_v</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">exp_s</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">norm_v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">iszerovec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">_eps</span><span class="p">):</span>
            <span class="c1"># result will be a unit quaternion</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">exp_s</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">/</span> <span class="n">norm_v</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">norm_v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">_eps</span><span class="p">:</span>
            <span class="c1"># result will be a unit quaternion</span>
            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.inner"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.inner">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inner product of quaternions</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        ``q1.inner(q2)`` is the dot product of the equivalent vectors,</span>
<span class="sd">        ie. ``numpy.dot(q1.vec, q2.vec)``.</span>
<span class="sd">        The value of ``q.inner(q)`` is the same as ``q.norm ** 2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).inner(Quaternion([5,6,7,8]))</span>
<span class="sd">            &gt;&gt;&gt; numpy.dot([1,2,3,4], [5,6,7,8])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qinner`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">Quaternion</span>
        <span class="p">),</span> <span class="s2">&quot;operands to inner must be Quaternion subclass&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">qinner</span><span class="p">,</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="c1"># -------------------------------------------- operators</span>

<div class="viewcode-block" id="Quaternion.__eq__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__eq__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``==`` operator</span>

<span class="sd">        :return: Equality of two operands</span>
<span class="sd">        :rtype: bool or list of bool</span>
<span class="sd">        ``q1 == q2`` is True if ``q1` is elementwise equal to ``q2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q1 = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q2 = Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; q1 == q1</span>
<span class="sd">            &gt;&gt;&gt; q1 == q2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) == q1</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) == q2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) == Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>

<span class="sd">        :seealso: :func:`__ne__` :func:`~spatialmath.base.quaternions.qisequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s2">&quot;operands to == are of different types&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">qisequal</span><span class="p">,</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.__ne__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__ne__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``!=`` operator</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        ``q1 != q2`` is True if ``q` is elementwise not equal to ``q2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q1 = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q2 = Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; q1 != q1</span>
<span class="sd">            &gt;&gt;&gt; q1 != q2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) != q1</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) != q2</span>

<span class="sd">        :seealso: :func:`__ne__` :func:`~spatialmath.base.quaternions.qisequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s2">&quot;operands to == are of different types&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">not</span> <span class="n">smb</span><span class="o">.</span><span class="n">qisequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.__mul__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__mul__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``*`` operator</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        - ``q1 * q2`` is the Hamilton product of two quaternions</span>
<span class="sd">        - ``q * s`` is the scalar product, where ``s`` is a scalar</span>

<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">                   Multiplicands                   Product</span>
<span class="sd">        -------------------------------   --------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">        Quaternion       Quaternion       Quaternion      Hamilton product</span>
<span class="sd">        Quaternion       UnitQuaternion   Quaternion      Hamilton product</span>
<span class="sd">        Quaternion       scalar           Quaternion      scalar product</span>
<span class="sd">        ==============   ==============   ==============  ================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``prod = left * right``</span>
<span class="sd">         1      N       N    ``prod[i] = left * right[i]``</span>
<span class="sd">         N      1       N    ``prod[i] = left[i] * right``</span>
<span class="sd">         N      N       N    ``prod[i] = left[i] * right[i]``</span>
<span class="sd">         N      M       -    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * 2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) * 2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) * Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) * Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>

<span class="sd">        :seealso: :func:`__rmul__` :func:`__imul__` :func:`~spatialmath.base.quaternions.qqmul`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="c1"># quaternion * [unit]quaternion case</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">qqmul</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># quaternion * scalar case</span>
            <span class="c1"># print(&#39;scalar * quat&#39;)</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">([</span><span class="n">right</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">left</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operands to * are of different types&quot;</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span>
        <span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``*`` operator</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ``s * q`` is the scalar product, where ``s`` is a scalar.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; 2 * Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; 2 * Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>

<span class="sd">        :seealso: :func:`__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># scalar * quaternion case</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">([</span><span class="n">left</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">right</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__imul__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``*=`` operator</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ``q1 *= q2`` sets ``q1 := q1 * q2``</span>
<span class="sd">        ``q1 *= s`` sets ``q1 := q1 * s`` where ``s`` is a scalar</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q *= Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q *= 2</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>

<span class="sd">        :seealso: :func:`__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<div class="viewcode-block" id="Quaternion.__pow__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__pow__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``**`` operator</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q ** N`` computes the product of ``q`` with itself ``N-1`` times, where ``N`` must be</span>
<span class="sd">        an integer.  If ``N``&lt;0 the result is conjugated.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([1,2,3,4]) ** 2)</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([1,2,3,4]) ** -1)</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) ** 2)</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qpow`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qpow</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``=**`` operator</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q **= N`` computes the product of ``q`` with itself ``N-1`` times, where ``N`` must be</span>
<span class="sd">        an integer.  If ``N``&lt;0 the result is conjugated.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q **= 2</span>
<span class="sd">            &gt;&gt;&gt; q</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            &gt;&gt;&gt; q **= 2</span>
<span class="sd">            &gt;&gt;&gt; q</span>


<span class="sd">        :seealso: :func:`__pow__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<div class="viewcode-block" id="Quaternion.__truediv__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__truediv__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Quaternion</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># Quaternion division not supported</span></div>

<div class="viewcode-block" id="Quaternion.__add__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__add__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``+`` operator</span>

<span class="sd">        :return: sum</span>
<span class="sd">        :rtype: Quaternion, UnitQuaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ==============   ==============   ==============  ===================</span>
<span class="sd">                   Operands                            Sum</span>
<span class="sd">        -------------------------------   -----------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ===================</span>
<span class="sd">        Quaternion       Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       scalar           Quaternion      add to each element</span>
<span class="sd">        UnitQuaternion   Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      add to each element</span>
<span class="sd">        ==============   ==============   ==============  ===================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``sum = left + right``</span>
<span class="sd">         1      N       N    ``sum[i] = left + right[i]``</span>
<span class="sd">         N      1       N    ``sum[i] = left[i] + right``</span>
<span class="sd">         N      N       N    ``sum[i] = left[i] + right[i]``</span>
<span class="sd">         N      M       -    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        A scalar of length N is a list, tuple or numpy array.</span>
<span class="sd">        A 3-vector of length N is a 3xN numpy array, where each column is a 3-vector.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) + Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) + Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) + Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># results is not in the group, return an array, not a class</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s2">&quot;operands to + are of different types&quot;</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span></div>

<div class="viewcode-block" id="Quaternion.__sub__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__sub__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Quaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``-`` operator</span>

<span class="sd">        :return: difference</span>
<span class="sd">        :rtype: Quaternion, UnitQuaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ==============   ==============   ==============  ==========================</span>
<span class="sd">                   Operands                          Difference</span>
<span class="sd">        -------------------------------   ------------------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ==========================</span>
<span class="sd">        Quaternion       Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       scalar           Quaternion      subtract from each element</span>
<span class="sd">        UnitQuaternion   Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      subtract from each element</span>
<span class="sd">        ==============   ==============   ==============  ==========================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``diff = left - right``</span>
<span class="sd">         1      N       N    ``diff[i] = left - right[i]``</span>
<span class="sd">         N      1       N    ``diff[i] = left[i] - right``</span>
<span class="sd">         N      N       N    ``diff[i] = left[i] - right[i]``</span>
<span class="sd">         N      M       -    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        A scalar of length N is a list, tuple or numpy array.</span>
<span class="sd">        A 3-vector of length N is a 3xN numpy array, where each column is a 3-vector.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) - Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) - Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) - Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># results is not in the group, return an array, not a class</span>
        <span class="c1"># TODO allow class +/- a conformant array</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s2">&quot;operands to - are of different types&quot;</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded unary ``-`` operator</span>

<span class="sd">        :rtype: Quaternion or UnitQuaternion</span>

<span class="sd">        ``-q`` is a quaternion with all its components negated.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; -Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; -Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span>
            <span class="p">[</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># pylint: disable=invalid-unary-operand-type</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Readable representation of pose (superclass method)</span>

<span class="sd">        :return: readable representation of the pose as a list of arrays</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;([])&quot;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># need to indent subsequent lines of the native repr string by 4 spaces</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># format this as a list of ndarrays</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="o">+</span> <span class="s2">&quot;([</span><span class="se">\n</span><span class="s2">  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot; ])&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string for IPython (superclass method)</span>

<span class="sd">        :param p: pretty printer handle (ignored)</span>
<span class="sd">        :param cycle: pretty printer flag (ignored)</span>

<span class="sd">        Print colorized output when variable is displayed in IPython, ie. on a line by</span>
<span class="sd">        itself.</span>

<span class="sd">        Example::</span>

<span class="sd">            In [1]: x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string representation of quaternion</span>

<span class="sd">        :return: readable representation of quaternion</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Format the quaternion elements into a single line format.  For example::</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            &gt;&gt; q = UnitQuaternion.Rx(0.3)</span>

<span class="sd">        Note that unit quaternions are denoted by different delimiters for</span>
<span class="sd">        the vector part.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qnorm`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UnitQuaternion</span><span class="p">):</span>
            <span class="n">delim</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&gt;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delim</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">q2str</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="n">delim</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span></div>


<span class="c1"># ========================================================================= #</span>


<div class="viewcode-block" id="UnitQuaternion"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">UnitQuaternion</span><span class="p">(</span><span class="n">Quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unit quaternion class</span>

<span class="sd">    A unit quaternion can be considered an ordered pair :math:`(s, \vec{v})`</span>
<span class="sd">    where :math:`s \in \mathbb{R}` is the *scalar* part and :math:`\vec{v} = (v_x, v_y, v_z) \in \mathbb{R}^3`</span>
<span class="sd">    is the *vector* part and is often written as</span>

<span class="sd">    .. math:: \q = s \langle v_x, v_y, v_z \rangle</span>

<span class="sd">    and subject to a unit-length constraint :math:`s^2+v_x^2+v_y^2+v_z^2 = 1`.</span>

<span class="sd">    A unit-quaternion can be considered as a rotation :math:`\theta` about the</span>
<span class="sd">    vector :math:`\vec{v}`, so the unit quaternion can also be</span>
<span class="sd">    written as</span>

<span class="sd">    .. math:: \q = \cos \frac{\theta}{2} \sin \frac{\theta}{2} &lt;v_x v_y v_z&gt;</span>

<span class="sd">    The quaternion :math:`\q` and :math:`-\q` represent the equivalent rotation, and this is referred to</span>
<span class="sd">    as a double mapping.</span>

<span class="sd">    .. inheritance-diagram:: spatialmath.quaternion.UnitQuaternion</span>
<span class="sd">        :top-classes: collections.UserList</span>
<span class="sd">        :parts: 1</span>

<span class="sd">    The ``UnitQuaternion`` class inherits many methods from the ``Quaternion`` class</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="UnitQuaternion.__init__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">check</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion instance</span>

<span class="sd">        :param norm: explicitly normalize the quaternion [default True]</span>
<span class="sd">        :type norm: bool</span>
<span class="sd">        :param check: explicitly check validity of argument [default True]</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        - ``UnitQuaternion()`` constructs the identity quaternion 1&lt;0,0,0&gt;</span>
<span class="sd">        - ``UnitQuaternion(s, v)`` constructs a unit quaternion with specified</span>
<span class="sd">          real ``s`` and ``v`` vector parts. ``v`` is a 3-vector given as a</span>
<span class="sd">          list, tuple, or ndarray(3). If ``norm`` is True the resulting</span>
<span class="sd">          quaternion is normalized.</span>
<span class="sd">        - ``UnitQuaternion(v)`` constructs a unit quaternion with specified</span>
<span class="sd">          elements from ``v`` which is a 4-vector given as a list, tuple, or ndarray(4). Also known</span>
<span class="sd">          as the Euler parameters.</span>
<span class="sd">        - ``UnitQuaternion(M)`` construct a new unit quaternion with ``N`` values where ``Q`` is a Nx4 NumPy array</span>
<span class="sd">          whose rows are the quaternion in vector form</span>
<span class="sd">        - ``UnitQuaternion(R)`` constructs a unit quaternion from an SO(3)</span>
<span class="sd">          rotation matrix given as a ndarray(3,3). If ``check`` is True</span>
<span class="sd">          test the rotation submatrix for orthogonality.</span>
<span class="sd">        - ``UnitQuaternion(X)`` constructs a unit quaternion from the rotational</span>
<span class="sd">          part of ``X`` which is an SO3 or SE3 instance.  If len(X) &gt; 1 then</span>
<span class="sd">          the resulting unit quaternion is of the same length.</span>
<span class="sd">        - ``UnitQuaternion([q1, q2 .. qN])`` construct a new unit quaternion with ``N`` values where each element is a 4-vector</span>
<span class="sd">        - ``UnitQuaternion([Q1, Q2 .. QN])`` construct a new unit quaternion with ``N`` values where each element is a UnitQuaternion instance</span>
<span class="sd">        - ``UnitQuaternion([X1, X2 .. XN])`` construct a new unit quaternion with ``N`` values where each element is an SO3 or SE3 instance</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ()</span>
<span class="sd">            &gt;&gt;&gt; q         # repr()</span>
<span class="sd">            &gt;&gt;&gt; print(q)  # str()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># handle: UnitQuaternion(v)`` constructs a unit quaternion with specified elements</span>
        <span class="c1"># from ``v`` which is a 4-vector given as a list, tuple, or ndarray(4)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># single argument</span>
            <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
                <span class="c1"># create unit quaternion</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># passed a NumPy array, it could be:</span>
                <span class="c1">#  an SO(3) or SE(3) matrix</span>
                <span class="c1">#  a quaternion as a 1D array</span>
                <span class="c1">#  an array of quaternions as an nx4 array</span>

                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
                        <span class="c1"># UnitQuaternion(R) R is 3x3 rotation matrix</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;invalid rotation matrix provided to UnitQuaternion constructor&quot;</span>
                        <span class="p">)</span>
                <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
                    <span class="c1"># passed a 4-vector</span>
                    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># self.data = [smb.qpositive(x) for x in s]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array could not be interpreted as UnitQuaternion&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SO3</span><span class="p">):</span>
                <span class="c1"># UnitQuaternion(x) x is SO3 or SE3 (since SE3 is subclass of SO3)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SO3</span><span class="p">):</span>
                <span class="c1"># list of SO3 or SE3</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad argument to UnitQuaternion constructor&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># UnitQuaternion(s, v)   s is scalar, v is 3-vector</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad argument to UnitQuaternion constructor&quot;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_identity</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">qeye</span><span class="p">()</span>

<div class="viewcode-block" id="UnitQuaternion.isvalid"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vector is valid unit quaternion</span>

<span class="sd">        :param x: vector to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :arg check: explicitly check vector is unit length [default True]</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: True if the matrix has shape (4,).</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; UnitQuaternion.isvalid(np.r_[1, 0, 0, 0])</span>
<span class="sd">            &gt;&gt;&gt; UnitQuaternion.isvalid(np.r_[1, 2, 3, 4])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check</span> <span class="ow">or</span> <span class="n">smb</span><span class="o">.</span><span class="n">isunitvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SO3Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as a rotation matrix</span>

<span class="sd">        :return: equivalent rotational matrix</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        ``q.R`` returns the rotation matrix which describes the equivalent rotation. If ``len(x)`` is:</span>

<span class="sd">            - 1, return an ndarray with shape=(3,3)</span>
<span class="sd">            - N&gt;1, return ndarray with shape=(N,3,3)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q.R</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx([0.3, 0.4])</span>
<span class="sd">            &gt;&gt;&gt; q.R</span>

<span class="sd">        .. warning:: The i&#39;th rotation matrix is ``x[i,:,:]`` or simply</span>
<span class="sd">            ``x[i]``. This is different to the MATLAB version where the i&#39;th</span>
<span class="sd">            rotation matrix is ``x(:,:,i)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vec3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion unique vector part</span>

<span class="sd">        :return: vector part of unit quaternion</span>
<span class="sd">        :rtype: numpy array, shape=(3,)</span>

<span class="sd">        ``q.vec3`` is the vector part of a unit quaternion.  If ``q`` has a negative scalar</span>
<span class="sd">        part we take the vector part of ``-q``, since  ``q`` and ``-q`` represent the</span>
<span class="sd">        same rotation.</span>

<span class="sd">        This vector part is a minimal unique representation of the unit quaternion and can be used in</span>
<span class="sd">        optimization procedures such as bundle adjustment.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rz(-4)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q.vec3</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Vec3(q.vec3)</span>
<span class="sd">            &gt;&gt;&gt; print(q2)</span>
<span class="sd">            &gt;&gt;&gt; q == q2</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.Vec3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">q2v</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------- constructor variants</span>
<div class="viewcode-block" id="UnitQuaternion.Rx"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Rx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion object representing rotation about the X-axis</span>

<span class="sd">        :arg θ: rotation angle</span>
<span class="sd">        :type θ: array_like</span>
<span class="sd">        :arg unit: rotation unit &#39;rad&#39; [default] or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion(θ)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ``θ`` radians about the X-axis.</span>
<span class="sd">        - ``UnitQuaternion(θ, &#39;deg&#39;)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ``θ`` degrees about the X-axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0, 0.3, 0.6]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Ry"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Ry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Ry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion object representing rotation about the Y-axis</span>

<span class="sd">        :arg θ: rotation angle</span>
<span class="sd">        :type θ: array_like</span>
<span class="sd">        :arg unit: rotation unit &#39;rad&#39; [default] or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion(θ)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ``θ`` radians about the Y-axis.</span>
<span class="sd">        - ``UnitQuaternion(θ, &#39;deg&#39;)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ``θ`` degrees about the Y-axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Ry(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Ry([0, 0.3, 0.6]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Rz"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Rz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion object representing rotation about the Z-axis</span>

<span class="sd">        :arg θ: rotation angle</span>
<span class="sd">        :type θ: array_like</span>
<span class="sd">        :arg unit: rotation unit &#39;rad&#39; [default] or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion(θ)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ``θ`` radians about the Z-axis.</span>
<span class="sd">        - ``UnitQuaternion(θ, &#39;deg&#39;)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ``θ`` degrees about the Z-axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rz(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rz([0, 0.3, 0.6]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Rand"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Rand">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rand</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">theta_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new random unit quaternion</span>

<span class="sd">        :param N: number of random rotations</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :param theta_range: angular magnitude range [min,max], defaults to None -&gt; [0,pi].</span>
<span class="sd">        :type xrange: 2-element sequence, optional</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: random unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion.Rand()`` is a uniformly distributed random unit quaternion value.</span>
<span class="sd">        - ``SO3.Rand(N)`` is a unit quaternion instance containing a sequence of N random unit quaternion</span>
<span class="sd">          values.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rand())</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rand(3))</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.Rand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">qrand</span><span class="p">(</span><span class="n">theta_range</span><span class="o">=</span><span class="n">theta_range</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)],</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Eul"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Eul">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from Euler angles</span>

<span class="sd">        :param 𝚪: 3-vector of Euler angles</span>
<span class="sd">        :type 𝚪: 3 floats, array_like(3) or ndarray(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion.Eul(𝚪)`` is a unit quaternion that describes the 3D</span>
<span class="sd">          rotation defined by a 3-vector of Euler angles :math:`\Gamma = (\phi,</span>
<span class="sd">          \theta, \psi)` which correspond to consecutive rotations about the Z,</span>
<span class="sd">          Y, Z axes respectively.</span>

<span class="sd">        - ``UnitQuaternion.Eul(φ, θ, ψ)`` as above but the angles are provided</span>
<span class="sd">          as three scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Eul([0.1, 0.2, 0.3]))</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.RPY` :meth:`SE3.eul` :meth:`SE3.Eul` :meth:`~spatialmath.base.transforms3d.eul2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.RPY"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.RPY">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">RPY</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">*</span><span class="n">angles</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from roll-pitch-yaw angles</span>

<span class="sd">        :param 𝚪: 3-vector of roll-pitch-yaw angles</span>
<span class="sd">        :type 𝚪: 3 floats, array_like(3) or ndarray(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param unit: rotation order: &#39;zyx&#39; [default], &#39;xyz&#39;, or &#39;yxz&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion.RPY(𝚪)`` is a unit quaternion that describes the 3D</span>
<span class="sd">          rotation defined by a  3-vector of roll, pitch, yaw angles</span>
<span class="sd">          :math:`\Gamma = (r, p, y)` which correspond to successive rotations</span>
<span class="sd">          about the axes specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch</span>
<span class="sd">              about the new y-axis, then by roll about the new x-axis.</span>
<span class="sd">              Convention for a mobile robot with x-axis forward and y-axis</span>
<span class="sd">              sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the</span>
<span class="sd">              new y-axis, then by roll about the new z-axis. Convention for a</span>
<span class="sd">              robot gripper with z-axis forward and y-axis between the gripper</span>
<span class="sd">              fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the</span>
<span class="sd">              new x-axis, then by roll about the new z-axis. Convention for a</span>
<span class="sd">              camera with z-axis parallel to the optic axis and x-axis parallel</span>
<span class="sd">              to the pixel rows.</span>


<span class="sd">        - ``UnitQuaternion.RPY(⍺, β, 𝛾)`` as above but the angles are provided</span>
<span class="sd">          as three scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.RPY([0.1, 0.2, 0.3]))</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.Eul` :meth:`SE3.rpy` :meth:`SE3.RPY` :func:`~spatialmath.base.transforms3d.rpy2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="p">[</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.OA"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.OA">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">OA</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from two vectors</span>

<span class="sd">        :param o: 3-vector parallel to Y- axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :param a: 3-vector parallel to the Z-axis</span>
<span class="sd">        :type a: array_like</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``UnitQuaternion.OA(O, A)`` is a unit quaternion that describes the 3D rotation defined in terms of</span>
<span class="sd">        vectors parallel to the Y- and Z-axes of its reference frame.  In robotics these axes are</span>
<span class="sd">        respectively called the orientation and approach vectors defined such that</span>
<span class="sd">        R = [N O A] and N = O x A.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.OA([0,0,-1], [0,1,0]))</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Only the ``A`` vector is guaranteed to have the same direction in the resulting</span>
<span class="sd">            rotation matrix</span>
<span class="sd">            - ``O`` and ``A`` do not have to be unit-length, they are normalized</span>
<span class="sd">            - ``O`` and ``A` do not have to be orthogonal, so long as they are not parallel</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.oa2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">oa2r</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.AngVec"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.AngVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">AngVec</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from rotation angle and axis</span>

<span class="sd">        :param theta: rotation</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``UnitQuaternion.AngVec(θ, v)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of ``θ`` about the 3-vector ``v``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.AngVec(0, [1,0,0]))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.AngVec(90, [1,0,0], unit=&#39;deg&#39;))</span>

<span class="sd">        .. note:: :math:`\theta = 0` the result in an identity quaternion, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.angvec` :meth:`UnitQuaternion.exp` :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">s</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">v</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.EulerVec"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.EulerVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">EulerVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from an Euler rotation vector</span>

<span class="sd">        :param ω: rotation axis</span>
<span class="sd">        :type ω: 3-element array_like</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``UnitQuaternion.EulerVec(ω)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of :math:`\theta = \lVert \omega \rVert` about the</span>
<span class="sd">        unit 3-vector :math:`\omega / \lVert \omega \rVert`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.EulerVec([0.5,0,0]))</span>

<span class="sd">        .. note:: :math:`\theta \eq 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :meth:`SE3.angvec` :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;w must be a 3-vector&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Vec3"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Vec3">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Vec3</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from its vector part</span>

<span class="sd">        :param vec: vector part of unit quaternion</span>
<span class="sd">        :type vec: 3-element array_like</span>

<span class="sd">        ``UnitQuaternion.Vec(v)`` is a new unit quaternion with the specified vector part</span>
<span class="sd">        and the scalar part is</span>

<span class="sd">        .. math:: s = \sqrt{1 - v_x^2 - v_y^2 - v_z^2}</span>

<span class="sd">        The unit quaternion will always have a positive scalar part.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rz(-4)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q.vec3</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Vec3(q.vec3)</span>
<span class="sd">            &gt;&gt;&gt; print(q2)</span>
<span class="sd">            &gt;&gt;&gt; q == q2</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.vec3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">v2q</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span></div>

<div class="viewcode-block" id="UnitQuaternion.inv"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.inv">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of unit quaternion</span>

<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``q.inv()`` is the inverse of the unit-quaternion.  This is a group operation</span>
<span class="sd">        and the product of the unit-quaternion and its inverse is the identity quaternion.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3).inv())</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3).inv() * UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]).inv())</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qinv`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qconj</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="UnitQuaternion.qvmul"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.qvmul">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">qvmul</span><span class="p">(</span><span class="n">qv1</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">qv2</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply unit quaternions defined by unique vector parts</span>

<span class="sd">        :param qv1: vector representation of first multiplicand</span>
<span class="sd">        :type qv1: ndarray(3)</span>
<span class="sd">        :param qv1: vector representation of second multiplicand</span>
<span class="sd">        :type qv1: ndarray(3)</span>

<span class="sd">        ``UnitQuaternion(qv1, qv2)`` is the Hamilton product of two unit quaternions</span>
<span class="sd">        represented in minimal vector form.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Ry(-0.3)</span>
<span class="sd">            &gt;&gt;&gt; qv1 = q1.vec3</span>
<span class="sd">            &gt;&gt;&gt; qv1</span>
<span class="sd">            &gt;&gt;&gt; qv2 = q2.vec3</span>
<span class="sd">            &gt;&gt;&gt; qv = UQ.qvmul(qv1, qv2)</span>
<span class="sd">            &gt;&gt;&gt; qv</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Vec3(qv))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Ry(-0.3))</span>

<span class="sd">        :seealso: :meth:`UnitQuaternion.vec3` :meth:`UnitQuaternion.Vec3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">vvmul</span><span class="p">(</span><span class="n">qv1</span><span class="p">,</span> <span class="n">qv2</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.dot"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.dot">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R4</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rate of change of a unit quaternion in world frame</span>

<span class="sd">        :param ω: angular velocity in world frame</span>
<span class="sd">        :type ω: 3-element array_like</span>
<span class="sd">        :return: rate of change of unit quaternion</span>
<span class="sd">        :rtype: ndarray(4)</span>

<span class="sd">        ``q.dot(ω)`` is the rate of change of the elements of the unit quaternion ``q``</span>
<span class="sd">        which represents the orientation of a body frame with angular velocity ``ω`` in</span>
<span class="sd">        the world frame.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qdot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">qdot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.dotb"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.dotb">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">dotb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R4</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rate of change of a unit quaternion in body frame</span>

<span class="sd">        :param ω: angular velocity in body frame</span>
<span class="sd">        :type ω: 3-element array_like</span>
<span class="sd">        :return: rate of change of unit quaternion</span>
<span class="sd">        :rtype: ndarray(4)</span>

<span class="sd">        ``q.dotb(ω)`` is the rate of change of the elements of the unit quaternion ``q``</span>
<span class="sd">        which represents the orientation of a body frame with angular velocity ``ω`` in</span>
<span class="sd">        the body frame.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qdotb`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">qdotb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span></div>

    <span class="c1"># def mean(self, tol: float = 20) -&gt; SO3:</span>
    <span class="c1">#     &quot;&quot;&quot;Mean of a set of rotations</span>

    <span class="c1">#     :param tol: iteration tolerance in units of eps, defaults to 20</span>
    <span class="c1">#     :type tol: float, optional</span>
    <span class="c1">#     :return: the mean rotation</span>
    <span class="c1">#     :rtype: :class:`UnitQuaternion` instance.</span>

    <span class="c1">#     Computes the Karcher mean of the set of rotations within the unit quaternion instance.</span>

    <span class="c1">#     :references:</span>
    <span class="c1">#         - `**Hartley, Trumpf** - &quot;Rotation Averaging&quot; - IJCV 2011 &lt;https://users.cecs.anu.edu.au/~hartley/Papers/PDF/Hartley-Trumpf:Rotation-averaging:IJCV.pdf&gt;`_</span>
    <span class="c1">#         - `Karcher mean &lt;https://en.wikipedia.org/wiki/Karcher_mean`_</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     R_mean = self.SO3().mean(tol=tol)</span>
    <span class="c1">#     return R_mean.UnitQuaternion()</span>

<div class="viewcode-block" id="UnitQuaternion.__mul__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__mul__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">UnitQuaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply unit quaternion</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion, UnitQuaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">                   Multiplicands                   Product</span>
<span class="sd">        -------------------------------   --------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">        UnitQuaternion   Quaternion       Quaternion      Hamilton product</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   UnitQuaternion  Hamilton product</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      scalar product</span>
<span class="sd">        UnitQuaternion   3-vector         3-vector        vector rotation</span>
<span class="sd">        UnitQuaternion   3xN array        3xN array       vector rotations</span>
<span class="sd">        ==============   ==============   ==============  ================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Rx(0.4))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * 2)</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * [1, 2, 3])</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``prod = left * right``</span>
<span class="sd">         1      N       N    ``prod[i] = left * right[i]``</span>
<span class="sd">         N      1       N    ``prod[i] = left[i] * right``</span>
<span class="sd">         N      N       N    ``prod[i] = left[i] * right[i]``</span>
<span class="sd">         N      M       n/a    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        A scalar of length N is a list, tuple or numpy array.</span>
<span class="sd">        A 3-vector of length N is a 3xN numpy array, where each column is</span>
<span class="sd">        a 3-vector.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Rx(0.4))</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q *= UQ.Rx(0.4))</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Rx([0.4, 0.6]))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) * UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) * UQ.Rx([0.3, 0.6]))</span>

<span class="sd">        :seealso: :meth:`Quaternion.__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="c1"># quaternion * quaternion case (same class)</span>
            <span class="k">return</span> <span class="n">right</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">qqmul</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># quaternion * scalar case</span>
            <span class="c1"># print(&#39;scalar * quat&#39;)</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">([</span><span class="n">right</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">left</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># unit quaternion * vector</span>
            <span class="c1"># print(&#39;*: pose x array&#39;)</span>
            <span class="k">if</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># pose x vector</span>
                    <span class="c1"># print(&#39;*: pose x vector&#39;)</span>
                    <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">qvmul</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">smb</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="c1"># pose array x vector</span>
                    <span class="c1"># print(&#39;*: pose array x vector&#39;)</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qvmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">_A</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="p">):</span>
                <span class="c1"># pose x stack of vectors</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">qvmul</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">right</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad operands&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UnitQuaternion: operands to * are of different types&quot;</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__imul__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">UnitQuaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply unit quaternion in place</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: UnitQuaternion, Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        Multiplies a quaternion in place. If the right operand is a list,</span>
<span class="sd">        the result will be a list.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q *= UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q</span>

<span class="sd">        :seealso: :func:`__mul__`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<div class="viewcode-block" id="UnitQuaternion.__truediv__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__truediv__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">UnitQuaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``/`` operator</span>

<span class="sd">        :rtype: Quaternion or UnitQuaternion</span>

<span class="sd">        - ``q1 / q2`` is equivalent to ``q1 * q1.inv()``.</span>
<span class="sd">        - ``q / s`` performs elementwise division of the elements of ``q`` by</span>
<span class="sd">          ``s``. This is not a group operation so the result will be a</span>
<span class="sd">          Quaternion.</span>

<span class="sd">        ==============   ==============   ==============  ===========================</span>
<span class="sd">                   Multiplicands                   Quotient</span>
<span class="sd">        -------------------------------   -------------------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ===========================</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   UnitQuaternion  Hamilton product by inverse</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      element-wise division</span>
<span class="sd">        ==============   ==============   ==============  ===========================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / 2)</span>

<span class="sd">        For pose composition either or both operands may hold more than one value which</span>
<span class="sd">        results in the composition holding more than one value according to:</span>

<span class="sd">        =========   ==========   ====  =====================================</span>
<span class="sd">        len(left)   len(right)   len     operation</span>
<span class="sd">        =========   ==========   ====  =====================================</span>
<span class="sd">         1          1             1    ``quo = left * right.inv()``</span>
<span class="sd">         1          M             M    ``quo[i] = left * right[i].inv()``</span>
<span class="sd">         N          1             M    ``quo[i] = left[i] * right.inv()``</span>
<span class="sd">         M          M             M    ``quo[i] = left[i] * right[i].inv()``</span>
<span class="sd">        =========   ==========   ====  =====================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) / UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / UQ.Rx([0.3, 0.6]))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) / UQ.Rx([0.3, 0.6]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span>
                <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">smb</span><span class="o">.</span><span class="n">qqmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">smb</span><span class="o">.</span><span class="n">qconj</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">smb</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad operands&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.__eq__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__eq__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">UnitQuaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``==`` operator</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        ``q1 == q2`` is True if ``q1`` is elementwise equal to ``q2`` and accounts for the</span>
<span class="sd">        double mapping. Supports broadcasting.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q1 == q1</span>
<span class="sd">            &gt;&gt;&gt; q1 == (-q1)</span>
<span class="sd">            &gt;&gt;&gt; q1 == q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q1</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == UQ([q1, q2])</span>

<span class="sd">        :seealso: :func:`__ne__` :func:`~spatialmath.base.quaternions.qisequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span>
            <span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">smb</span><span class="o">.</span><span class="n">qisequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unitq</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.__ne__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__ne__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">UnitQuaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``!=`` operator</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        ``q1 != q2`` is True if ``q1`` is elementwise not equal to ``q2`` and accounts for the</span>
<span class="sd">        double mapping. Supports broadcasting.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q1 != q1</span>
<span class="sd">            &gt;&gt;&gt; q1 != (-q1)</span>
<span class="sd">            &gt;&gt;&gt; q1 != q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q1</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == UQ([q1, q2])</span>

<span class="sd">        :seealso: :func:`__eq__` :func:`~spatialmath.base.quaternions.qisequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span>
            <span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">not</span> <span class="n">smb</span><span class="o">.</span><span class="n">qisequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unitq</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__matmul__</span><span class="p">(</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">UnitQuaternion</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded @ operator</span>

<span class="sd">        :return: product :rtype: UnitQuaternion</span>

<span class="sd">        - ``q1 @ q2`` is the Hamilton product of ``q1`` and ``q2``, both unit</span>
<span class="sd">          quaternions, followed by explicit normalization.</span>

<span class="sd">        - `` q1 @= q2`` as above.</span>

<span class="sd">        .. note:: This operator is functionally equivalent to ``*`` but is more</span>
<span class="sd">            costly.  It is useful for cases where a pose is incrementally update</span>
<span class="sd">            over many cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">qqmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="p">)</span>

<div class="viewcode-block" id="UnitQuaternion.interp"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.interp">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">interp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">UnitQuaternion</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shortest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate between two unit quaternions</span>

<span class="sd">        :param end: final unit quaternion</span>
<span class="sd">        :type end: UnitQuaternion</span>
<span class="sd">        :param shortest: Take the shortest path along the great circle</span>
<span class="sd">        :param s: interpolation coefficient, range 0 to 1, or number of steps</span>
<span class="sd">        :type s: array_like or int</span>
<span class="sd">        :return: interpolated unit quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``q0.interp(q1, s)`` is a unit quaternion that is interpolated between</span>
<span class="sd">          ``q0`` when s=0 and ``q1`` when s=1. Spherical linear interpolation</span>
<span class="sd">          (slerp) is used.  If ``s`` is an ndarray(n) then the result will be</span>
<span class="sd">          a UnitQuaternion with n values.</span>

<span class="sd">        - ``q0.interp(q1, N)`` interpolate between ``q0`` and ``q1`` in ``N``</span>
<span class="sd">          steps.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3); q2 = UQ.Rz(-0.4)</span>
<span class="sd">            &gt;&gt;&gt; print(q1)</span>
<span class="sd">            &gt;&gt;&gt; print(q2)</span>
<span class="sd">            &gt;&gt;&gt; q1.interp(q2, 0)    # this is q1</span>
<span class="sd">            &gt;&gt;&gt; q1.interp(q2, 1,)   # this is q2</span>
<span class="sd">            &gt;&gt;&gt; q1.interp(q2, 0.5)  # this is in between</span>
<span class="sd">            &gt;&gt;&gt; q = q1.interp(q2, 11)  # in 11 steps</span>
<span class="sd">            &gt;&gt;&gt; len(q)</span>
<span class="sd">            &gt;&gt;&gt; q[0]                # this is q1</span>
<span class="sd">            &gt;&gt;&gt; q[5]                # this is in between</span>

<span class="sd">        .. note:: values of ``s`` are silently clipped to the range [0, 1]</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qslerp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO allow self to have len() &gt; 1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># enforce valid values</span>

        <span class="c1"># 2 quaternion form</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">UnitQuaternion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;end argument must be a UnitQuaternion&quot;</span><span class="p">)</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">vec</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">qinner</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span>

        <span class="c1"># If the dot product is negative, the quaternions</span>
        <span class="c1"># have opposite handed-ness and slerp won&#39;t take</span>
        <span class="c1"># the shorter path. Fix by reversing one quaternion.</span>
        <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q1</span> <span class="o">=</span> <span class="o">-</span><span class="n">q1</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span>

        <span class="c1"># shouldn&#39;t be needed by handle numerical errors: -eps, 1+eps cases</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Clip within domain of acos()</span>

        <span class="n">theta_0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">)</span>  <span class="c1"># theta_0 = angle between input vectors</span>

        <span class="n">qi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_0</span> <span class="o">*</span> <span class="n">sk</span>  <span class="c1"># theta = angle between v0 and result</span>

            <span class="n">s1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">))</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">q1</span> <span class="o">*</span> <span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q2</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>
            <span class="n">qi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.interp1"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.interp1">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">interp1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shortest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitQuaternion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a unit quaternion</span>

<span class="sd">        :param shortest: Take the shortest path along the great circle</span>
<span class="sd">        :param s: interpolation coefficient, range 0 to 1, or number of steps</span>
<span class="sd">        :type s: array_like or int</span>
<span class="sd">        :return: interpolated unit quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``q.interp1(s)`` is a unit quaternion that is interpolated between</span>
<span class="sd">          identity when s=0 and ``q`` when s=1. Spherical linear interpolation</span>
<span class="sd">          (slerp) is used.  If ``s`` is an ndarray(n) then the result will be</span>
<span class="sd">          a UnitQuaternion with n values.</span>

<span class="sd">        - ``q.interp1(N)`` interpolate between identity and ``q1`` in ``N``</span>
<span class="sd">          steps.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q.interp1(0)    # this is identity</span>
<span class="sd">            &gt;&gt;&gt; q.interp1(1)    # this is q</span>
<span class="sd">            &gt;&gt;&gt; q.interp1(0.5)  # this is in between</span>
<span class="sd">            &gt;&gt;&gt; qi = q.interp1(11)  # in 11 steps</span>
<span class="sd">            &gt;&gt;&gt; len(qi)</span>
<span class="sd">            &gt;&gt;&gt; qi[0]                # this is q1</span>
<span class="sd">            &gt;&gt;&gt; qi[5]                # this is in between</span>

<span class="sd">        .. note:: values of ``s`` are silently clipped to the range [0, 1]</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qslerp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO allow self to have len() &gt; 1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># enforce valid values</span>

        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># s</span>

        <span class="c1"># If the dot product is negative, the quaternions</span>
        <span class="c1"># have opposite handed-ness and slerp won&#39;t take</span>
        <span class="c1"># the shorter path. Fix by reversing one quaternion.</span>
        <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span>

        <span class="c1"># shouldn&#39;t be needed by handle numerical errors: -eps, 1+eps cases</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Clip within domain of acos()</span>

        <span class="n">theta_0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">)</span>  <span class="c1"># theta_0 = angle between input vectors</span>

        <span class="n">qi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_0</span> <span class="o">*</span> <span class="n">sk</span>  <span class="c1"># theta = angle between v0 and result</span>

            <span class="n">s1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">))</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>
            <span class="n">qi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.increment"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.increment">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">ArrayLike3</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quaternion incremental update</span>

<span class="sd">        :param w: angular displacement, Euler vector</span>
<span class="sd">        :type w: array_like(3)</span>
<span class="sd">        :param normalize: normalize the result, defaults to False</span>
<span class="sd">        :type normalize: bool, optional</span>

<span class="sd">        .. note:: The object state is updated</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># is (v, theta) or None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">unitvec_norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># zero update</span>
            <span class="k">return</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span>

        <span class="n">updated</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">qqmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ds</span><span class="p">,</span> <span class="n">dv</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">qunit</span><span class="p">(</span><span class="n">updated</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">updated</span><span class="p">]</span></div>

<div class="viewcode-block" id="UnitQuaternion.plot"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.plot">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot unit quaternion as a coordinate frame</span>

<span class="sd">        :param `**kwargs`: plotting options</span>

<span class="sd">        - ``q.plot()`` displays the orientation ``q`` as a coordinate frame in 3D.</span>
<span class="sd">          There are many options, see the links below.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q.plot(frame=&#39;A&#39;, color=&#39;green&#39;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trplot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">smb</span><span class="o">.</span><span class="n">trplot</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.animate"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.animate">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">animate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot unit quaternion as an animated coordinate frame</span>

<span class="sd">        :param start: initial pose, defaults to null/identity</span>
<span class="sd">        :type start: UnitQuaternion</span>
<span class="sd">        :param `**kwargs`: plotting options</span>

<span class="sd">        - ``q.animate()`` displays the orientation ``q`` as a coordinate frame moving</span>
<span class="sd">          from the origin in either 3D.  There are</span>
<span class="sd">          many options, see the links below.</span>
<span class="sd">        - ``q.animate(*args, start=q1)`` displays the orientation ``q`` as a coordinate</span>
<span class="sd">          frame moving from orientation ``q11``, in 3D.  There are</span>
<span class="sd">          many options, see the links below.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; X = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; X.animate(frame=&#39;A&#39;, color=&#39;green&#39;)</span>
<span class="sd">            &gt;&gt;&gt; X.animate(start=UQ.Ry(0.2))</span>

<span class="sd">        :see :func:`~spatialmath.base.transforms3d.tranimate` :func:`~spatialmath.base.transforms3d.trplot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tranimate</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tranimate</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.rpy"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.rpy">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rpy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">R3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as roll-pitch-yaw angles</span>

<span class="sd">        :param order: angle sequence order, default to &#39;zyx&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of roll-pitch-yaw angles</span>
<span class="sd">        :rtype: ndarray(3) or ndarray(n,3)</span>

<span class="sd">        ``q.rpy`` is the roll-pitch-yaw angle representation of the 3D rotation.  The angles are</span>
<span class="sd">        a 3-vector :math:`(r, p, y)` which correspond to successive rotations about the axes</span>
<span class="sd">        specified by ``order``:</span>

<span class="sd">            - &#39;zyx&#39; [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - &#39;xyz&#39;, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - &#39;yxz&#39;, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        If ``len(x)`` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(N,3)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rx(0.3).rpy()</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rz([0.2, 0.3]).rpy()</span>

<span class="sd">        :seealso: :meth:`SE3.RPY` :func:`~spatialmath.base.transforms3d.tr2rpy`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="UnitQuaternion.eul"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.eul">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">eul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">R3</span><span class="p">,</span> <span class="n">RNx3</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as Euler angles</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of Euler angles</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        ``q.eul`` is the Euler angle representation of the rotation.  Euler angles are</span>
<span class="sd">        a 3-vector :math:`(\phi, \theta, \psi)` which correspond to consecutive</span>
<span class="sd">        rotations about the Z, Y, Z axes respectively.</span>

<span class="sd">        If ``len(x)`` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(N,3)</span>

<span class="sd">        - ndarray with shape=(3,), if len(R) == 1</span>
<span class="sd">        - ndarray with shape=(N,3), if len(R) = N &gt; 1</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).eul()</span>
<span class="sd">            &gt;&gt;&gt; UQ.Ry([0.3, 0.4]).eul()</span>

<span class="sd">        :seealso: :meth:`SE3.Eul` :func:`~spatialmath.base.transforms3d.tr2eul`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smb</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="UnitQuaternion.angvec"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.angvec">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">angvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">R3</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as angle and rotation vector</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param check: check that rotation matrix is valid</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: :math:`(\theta, {\bf v})`</span>
<span class="sd">        :rtype: float, ndarray(3)</span>

<span class="sd">        ``q.angvec()`` is a tuple :math:`(\theta, v)` containing the rotation</span>
<span class="sd">        angle and a rotation axis which is equivalent to the rotation of</span>
<span class="sd">        the unit quaternion ``q``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).angvec()</span>

<span class="sd">        :seealso: :meth:`Quaternion.AngVec` :meth:`UnitQuaternion.log` :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smb</span><span class="o">.</span><span class="n">tr2angvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>

    <span class="c1"># def log(self):</span>
    <span class="c1">#     r&quot;&quot;&quot;</span>
    <span class="c1">#     Logarithm of unit quaternion</span>

    <span class="c1">#     :rtype: Quaternion instance</span>

    <span class="c1">#     ``q.log()`` is the logarithm of the unit quaternion ``q``, ie.</span>

    <span class="c1">#     .. math::</span>

    <span class="c1">#          0  \langle \frac{\mathb{v}}{\| \mathbf{v} \|} \acos s \rangle</span>

    <span class="c1">#     Example:</span>

    <span class="c1">#     .. runblock:: pycon</span>

    <span class="c1">#         &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
    <span class="c1">#         &gt;&gt;&gt; q = UnitQuaternion.Rx(0.3)</span>
    <span class="c1">#         &gt;&gt;&gt; print(q.log())</span>

    <span class="c1">#     :reference: `Wikipedia &lt;https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions&gt;`_</span>

    <span class="c1">#     :seealso: :meth:`Quaternion.Quaternion.log`, `~spatialmath.quaternion.Quaternion.exp`</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return Quaternion(s=0, v=math.acos(self.s) * smb.unitvec(self.v))</span>

<div class="viewcode-block" id="UnitQuaternion.angdist"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.angdist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">angdist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">UnitQuaternion</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angular distance metric between unit quaternions</span>

<span class="sd">        :param other: second unit quaternion</span>
<span class="sd">        :type other: UnitQuaternion instance</span>
<span class="sd">        :param metric: metric, default is 3</span>
<span class="sd">        :type metric: int</span>
<span class="sd">        :raises TypeError: if other is not a UnitQuaternion</span>
<span class="sd">        :return: angle in radians</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ``q1.angdist(q2)`` is the geodesic norm, or geodesic distance between two</span>
<span class="sd">        unit quaternions.  We can consider it as the angle between two quaternions.</span>

<span class="sd">        Several metrics are supported:</span>

<span class="sd">        ======   ===============================================================</span>
<span class="sd">        Metric   Details</span>
<span class="sd">        ======   ===============================================================</span>
<span class="sd">        0        :math:`1 - | \q_1 \bullet \q_2 | \in [0, 1]`</span>
<span class="sd">        1        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        2        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        3        :math:`2 \tan^{-1} \| \q_1 \pm \q_2\| / \|\q_1 \mp \q_2\| \in [0, \pi/2]`</span>
<span class="sd">        4        :math:`\cos^{-1} \left( 2 (\q_1 \bullet \q_2)^2 - 1\right) \in [0, 1]`</span>
<span class="sd">        ======   ===============================================================</span>

<span class="sd">        Metric 3 computes the sum and difference of the quaternions and uses</span>
<span class="sd">        the largest value in the denominator.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; q1 = UnitQuaternion.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UnitQuaternion.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(q1.angdist(q1))</span>
<span class="sd">            &gt;&gt;&gt; print(q1.angdist(q2))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - metrics 1, 2, 4 can throw ValueError &quot;math domain error&quot; due to</span>
<span class="sd">              numeric errors which push the argument of ``acos()`` marginally</span>
<span class="sd">              outside its domain [0, 1].</span>
<span class="sd">            - metrics 2 and 3 are equivalent, but 3 is more robust</span>
<span class="sd">            - SMTB-MATLAB uses metric 3 for UnitQuaternion.angle()</span>
<span class="sd">            - MATLAB&#39;s quaternion.dist() uses metric 4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">UnitQuaternion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bad operand&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">metric3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">smb</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>

            <span class="n">measure</span> <span class="o">=</span> <span class="n">metric3</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.SO3"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.SO3">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">SO3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SO3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as SO3 instance</span>

<span class="sd">        :return: an SO(3) representation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``q.SO3()`` is an ``SO3`` instance representing the same rotation</span>
<span class="sd">        as the unit quaternion ``q``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).SO3()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SO3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.SE3"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.SE3">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">SE3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as SE3 instance</span>

<span class="sd">        :return: an SE(3) representation</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``q.SE3()`` is an ``SE3`` instance representing the same rotation</span>
<span class="sd">        as the unit quaternion ``q`` and with zero translation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).SE3()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SE3</span><span class="p">(</span><span class="n">smb</span><span class="o">.</span><span class="n">r2t</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">exec</span><span class="p">(</span>
        <span class="nb">open</span><span class="p">(</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
            <span class="o">/</span> <span class="s2">&quot;tests&quot;</span>
            <span class="o">/</span> <span class="s2">&quot;test_quaternion.py&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>  <span class="c1"># pylint: disable=exec-used</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-, Peter Corke..
      <span class="lastupdated">Last updated on 30-Jan-2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>