<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spatialmath.quaternion &mdash; Spatial Maths package 0.11.0
 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Spatial Maths package
            <img src="../../_static/CartesianSnakes_LogoW.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spatialmath.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indices.html">Indices</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Spatial Maths package</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>spatialmath.quaternion</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spatialmath.quaternion</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes to abstract quaternions and unit-quaternions.</span>

<span class="sd">To use::</span>

<span class="sd">    from spatialmath.quaternion import *</span>
<span class="sd">    T = UnitQuaternion.Rx(0.3)</span>

<span class="sd">    import spatialmath as sm</span>
<span class="sd">    T = sm.UnitQuaternion.Rx(0.3)</span>

<span class="sd"> .. inheritance-diagram:: spatialmath.quaternion</span>
<span class="sd">    :top-classes: collections.UserList</span>
<span class="sd">    :parts: 1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=invalid-name</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Type</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">spatialmath.pose3d</span> <span class="kn">import</span> <span class="n">SO3</span><span class="p">,</span> <span class="n">SE3</span>
<span class="kn">from</span> <span class="nn">spatialmath.baseposelist</span> <span class="kn">import</span> <span class="n">BasePoseList</span>

<span class="n">_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

<div class="viewcode-block" id="Quaternion"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion">[docs]</a><span class="k">class</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="n">BasePoseList</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion class</span>

<span class="sd">    A quaternion can be considered an ordered pair :math:`(s, \vec{v})`</span>
<span class="sd">    where :math:`s \in \mathbb{R}` is the *scalar* part and :math:`\vec{v} = (v_x, v_y, v_z) \in \mathbb{R}^3`</span>
<span class="sd">    is the *vector* part and is often written as</span>

<span class="sd">    .. math:: \q = s \langle v_x, v_y, v_z \rangle</span>

<span class="sd">    .. inheritance-diagram:: spatialmath.quaternion.Quaternion</span>
<span class="sd">       :top-classes: collections.UserList</span>
<span class="sd">       :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quaternion.__init__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new quaternion</span>

<span class="sd">        :param s: scalar</span>
<span class="sd">        :type s: float</span>
<span class="sd">        :param v: vector</span>
<span class="sd">        :type v: 3-element array_like</span>

<span class="sd">        - ``Quaternion()`` constructs a zero quaternion</span>
<span class="sd">        - ``Quaternion(s, v)`` construct a new quaternion from the scalar ``s``</span>
<span class="sd">          and the vector ``v``</span>
<span class="sd">        - ``Quaternion(q)`` construct a new quaternion from the 4-vector</span>
<span class="sd">          ``q = [s, v]``</span>
<span class="sd">        - ``Quaternion([q1, q2 .. qN])`` construct a new quaternion with ``N``</span>
<span class="sd">          values where each element is a 4-vector</span>
<span class="sd">        - ``Quaternion([Q1, Q2 .. QN])`` construct a new quaternion with ``N``</span>
<span class="sd">          values where each element is a Quaternion instance</span>
<span class="sd">        - ``Quaternion(M)`` construct a new quaternion with ``N`` values where</span>
<span class="sd">          ``Q`` is a 4xN NumPy array.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion()</span>
<span class="sd">            &gt;&gt;&gt; Quaternion(1, [2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q=Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            &gt;&gt;&gt; len(q)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># single argument</span>
            <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Quaternion(s, v)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">)]]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad argument to Quaternion constructor&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quaternion.Pure"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.Pure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Pure</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a pure quaternion from a vector</span>

<span class="sd">        :param v: vector</span>
<span class="sd">        :type v: 3-element array_like</span>

<span class="sd">        ``Quaternion.Pure(v)`` is a Quaternion with a zero scalar part and the</span>
<span class="sd">        vector part set to ``v``,</span>
<span class="sd">        ie. :math:`q = 0 \langle v_x, v_y, v_z \rangle`</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion.Pure([1,2,3]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_identity</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the object&#39;s interal matrix representation</span>

<span class="sd">        :return: (4,)</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span>

<div class="viewcode-block" id="Quaternion.isvalid"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vector is valid quaternion</span>

<span class="sd">        :param x: vector to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :arg check: explicitly check vector is unit length [default True]</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: True if the matrix has shape (4,).</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; Quaternion.isvalid(np.r_[1, 0, 0, 0])</span>
<span class="sd">            &gt;&gt;&gt; Quaternion.isvalid(np.r_[1, 2, 3, 4])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scalar part of quaternion</span>

<span class="sd">        :return: scalar part of quaternion</span>
<span class="sd">        :rtype: float or numpy.ndarray</span>

<span class="sd">        ``q.s`` is the scalar part.  If `len(q)` is:</span>

<span class="sd">            - 1, return a scalar float</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,) is returned.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).s</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">s</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Vector part of quaternion</span>

<span class="sd">        :return: vector part of quaternion</span>
<span class="sd">        :rtype: NumPy ndarray</span>

<span class="sd">        ``q.v`` is the vector part.  If `len(q)` is:</span>

<span class="sd">            - 1, return a NumPy array shape=(3,)</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,3).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).v</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).v</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">v</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quaternion as a vector</span>

<span class="sd">        :return: quaternion expressed as a 4-vector</span>
<span class="sd">        :rtype: numpy ndarray, shape=(4,)</span>

<span class="sd">        ``q.vec`` is the quaternion as a vector.  If `len(q)` is:</span>

<span class="sd">            - 1, return a NumPy array shape=(4,)</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,4).</span>

<span class="sd">        The quaternion coefficients are in the order (s, vx, vy, vz), ie. with</span>
<span class="sd">        the scalar (real part) first.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).vec</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).vec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vec_xyzs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quaternion as a vector</span>

<span class="sd">        :return: quaternion expressed as a 4-vector</span>
<span class="sd">        :rtype: numpy ndarray, shape=(4,)</span>

<span class="sd">        ``q.vec_xyzs`` is the quaternion as a vector.  If `len(q)` is:</span>

<span class="sd">            - 1, return a NumPy array shape=(4,)</span>
<span class="sd">            - N&gt;1, return a NumPy array shape=(N,4).</span>

<span class="sd">        The quaternion coefficients are in the order (vx, vy, vz, s), ie. with</span>
<span class="sd">        the scalar (real part) last. This is useful when exporting to other</span>
<span class="sd">        packages like three.js or pybullet.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).vec_xyzs</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).vec_xyzs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix equivalent of quaternion</span>

<span class="sd">        :rtype: Numpy array, shape=(4,4)</span>

<span class="sd">        ``q.matrix`` is a 4x4 matrix which encodes the arithmetic rules of Hamilton multiplication.</span>
<span class="sd">        This matrix, multiplied by the 4-vector equivalent of a second quaternion, results in the 4-vector</span>
<span class="sd">        equivalent of the Hamilton product.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).matrix</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * Quaternion([5,6,7,8])   # Hamilton product</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).matrix @ Quaternion([5,6,7,8]).vec  # matrix-vector product</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.matrix`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>


<div class="viewcode-block" id="Quaternion.conj"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conjugate of quaternion</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q.conj()`` is the quaternion ``q`` with the vector part negated, ie.</span>
<span class="sd">        :math:`q = s \langle -v_x, -v_y, -v_z \rangle`</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion.Pure([1,2,3]).conj())</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.conj`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="Quaternion.norm"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Norm of quaternion</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        ``q.norm()`` is the norm or length of the quaternion </span>
<span class="sd">        :math:`\sqrt{s^2 + v_x^2 + v_y^2 + v_z^2}`</span>


<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).norm()</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).norm()</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qnorm`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">qnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">qnorm</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="Quaternion.unit"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.unit">[docs]</a>    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion</span>

<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``q.unit()`` is the quaternion ``q`` normalized to have a unit length.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; print(q.unit())</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]).unit())</span>

<span class="sd">        Note that the return type is different, a ``UnitQuaternion``, which is</span>
<span class="sd">        distinguished by the use of double angle brackets to delimit the </span>
<span class="sd">        vector part.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.qnorm`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.log"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logarithm of quaternion</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q.log()`` is the logarithm of the quaternion ``q``, ie.</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">             \ln \| q \|,  \langle \frac{\vec{v}}{\| \vec{v} \|} \cos^{-1} \frac{s}{\| q \|} \rangle</span>

<span class="sd">        For a ``UnitQuaternion`` the logarithm is a pure quaternion whose vector</span>
<span class="sd">        part :math:`\vec{v}` and :math:`\vec{v}/2` is a Euler vector: parallel</span>
<span class="sd">        to the axis of rotation and whose norm is the magnitude of rotation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion, UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; from math import pi</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1, 2, 3, 4])</span>
<span class="sd">            &gt;&gt;&gt; print(q.log())</span>
<span class="sd">            &gt;&gt;&gt; q = UnitQuaternion.Rx(pi / 2)</span>
<span class="sd">            &gt;&gt;&gt; print(q.log())</span>

<span class="sd">        :reference: `Wikipedia &lt;https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions&gt;`_</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.Quaternion.exp`, :func:`~spatialmath.quaternion.Quaternion.log`, :func:`~spatialmath.quaternion.UnitQuaternion.angvec`, </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span> <span class="o">*</span> <span class="n">base</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.exp"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exponential of quaternion</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q.exp()`` is the exponential of the quaternion ``q``, ie.</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">             e^s \cos \| v \|,  \langle e^s \frac{\vec{v}}{\| \vec{v} \|} \sin \| \vec{v} \| \rangle</span>

<span class="sd">        For a pure quaternion with vector value :math:`\vec{v}` the the result</span>
<span class="sd">        is a unit quaternion equivalent to a rotation defined by</span>
<span class="sd">        :math:`2\vec{v}` intepretted as an Euler vector, that is, parallel to</span>
<span class="sd">        the axis of rotation and whose norm is the magnitude of rotation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; from math import pi</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1, 2, 3, 4])</span>
<span class="sd">            &gt;&gt;&gt; print(q.exp())</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion.Pure([pi / 4, 0, 0])</span>
<span class="sd">            &gt;&gt;&gt; print(q.exp())  # result is a UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; print(q.exp().angvec())</span>

<span class="sd">        :reference: `Wikipedia &lt;https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions&gt;`_</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.Quaternion.log`, :func:`~spatialmath.quaternion.UnitQuaternion.log`, :func:`~spatialmath.quaternion.UnitQuaternion.AngVec`, :func:`~spatialmath.quaternion.UnitQuaternion.EulerVec`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exp_s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="n">norm_v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">exp_s</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">norm_v</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">exp_s</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">/</span> <span class="n">norm_v</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">norm_v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">_eps</span><span class="p">:</span>
            <span class="c1"># result will be a unit quaternion</span>
            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quaternion.inner"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inner product of quaternions</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        ``q1.inner(q2)`` is the dot product of the equivalent vectors, </span>
<span class="sd">        ie. ``numpy.dot(q1.vec, q2.vec)``.</span>
<span class="sd">        The value of ``q.inner(q)`` is the same as ``q.norm ** 2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]).inner(Quaternion([5,6,7,8]))</span>
<span class="sd">            &gt;&gt;&gt; numpy.dot([1,2,3,4], [5,6,7,8])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.inner`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Quaternion</span><span class="p">),</span> \
            <span class="s1">&#39;operands to inner must be Quaternion subclass&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">inner</span><span class="p">,</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="c1">#-------------------------------------------- operators</span>

<div class="viewcode-block" id="Quaternion.__eq__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span> <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``==`` operator</span>

<span class="sd">        :return: Equality of two operands</span>
<span class="sd">        :rtype: bool or list of bool</span>
<span class="sd">        ``q1 == q2`` is True if ``q1` is elementwise equal to ``q2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q1 = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q2 = Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; q1 == q1</span>
<span class="sd">            &gt;&gt;&gt; q1 == q2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) == q1</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) == q2</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) == Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>

<span class="sd">        :seealso: :func:`__ne__`, :func:`~spatialmath.base.quaternions.isequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> \
            <span class="s1">&#39;operands to == are of different types&#39;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">isequal</span><span class="p">,</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.__ne__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__ne__">[docs]</a>    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``!=`` operator</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        ``q1 != q2`` is True if ``q` is elementwise not equal to ``q2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; q1 = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q2 = Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; q1 != q1</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; q1 != q2</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) != q1</span>
<span class="sd">            [False, True]</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) != q2</span>
<span class="sd">            [True, False]</span>

<span class="sd">        :seealso: :func:`__ne__`, :func:`~spatialmath.base.quaternions.isequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s1">&#39;operands to == are of different types&#39;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">not</span> <span class="n">base</span><span class="o">.</span><span class="n">isequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Quaternion.__mul__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``*`` operator</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        - ``q1 * q2`` is the Hamilton product of two quaternions</span>
<span class="sd">        - ``q * s`` is the scalar product, where ``s`` is a scalar</span>

<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">                   Multiplicands                   Product</span>
<span class="sd">        -------------------------------   --------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">        Quaternion       Quaternion       Quaternion      Hamilton product</span>
<span class="sd">        Quaternion       UnitQuaternion   Quaternion      Hamilton product</span>
<span class="sd">        Quaternion       scalar           Quaternion      scalar product</span>
<span class="sd">        ==============   ==============   ==============  ================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``prod = left * right``</span>
<span class="sd">         1      N       N    ``prod[i] = left * right[i]``</span>
<span class="sd">         N      1       N    ``prod[i] = left[i] * right``</span>
<span class="sd">         N      N       N    ``prod[i] = left[i] * right[i]``</span>
<span class="sd">         N      M       -    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * Quaternion([5,6,7,8])</span>
<span class="sd">            -60.000000 &lt; 12.000000, 30.000000, 24.000000 &gt;</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * 2</span>
<span class="sd">            2.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) * 2</span>
<span class="sd">            2.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            10.000000 &lt; 12.000000, 14.000000, 16.000000 &gt;</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) * Quaternion([1,2,3,4])</span>
<span class="sd">            -28.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            -60.000000 &lt; 20.000000, 14.000000, 32.000000 &gt;</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) * Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            -28.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            -60.000000 &lt; 12.000000, 30.000000, 24.000000 &gt;</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) * Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            -28.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            -124.000000 &lt; 60.000000, 70.000000, 80.000000 &gt;</span>

<span class="sd">        :seealso: :func:`__rmul__`, :func:`__imul__`, :func:`~spatialmath.base.quaternions.qqmul`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="c1"># quaternion * [unit]quaternion case</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">qqmul</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># quaternion * scalar case</span>
            <span class="c1">#print(&#39;scalar * quat&#39;)</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">([</span><span class="n">right</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">left</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;operands to * are of different types&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``*`` operator</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ``s * q`` is the scalar product, where ``s`` is a scalar.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; 2 * Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; 2 * Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>

<span class="sd">        :seealso: :func:`__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># scalar * quaternion case</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">([</span><span class="n">left</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">right</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``*=`` operator</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ``q1 *= q2`` sets ``q1 := q1 * q2``</span>
<span class="sd">        ``q1 *= s`` sets ``q1 := q1 * s`` where ``s`` is a scalar</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q *= Quaternion([5,6,7,8])</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q *= 2</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>

<span class="sd">        :seealso: :func:`__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<div class="viewcode-block" id="Quaternion.__pow__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__pow__">[docs]</a>    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``**`` operator</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q ** N`` computes the product of ``q`` with itself ``N-1`` times, where ``N`` must be</span>
<span class="sd">        an integer.  If ``N``&lt;0 the result is conjugated.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([1,2,3,4]) ** 2)</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([1,2,3,4]) ** -1)</span>
<span class="sd">            &gt;&gt;&gt; print(Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) ** 2)</span>

<span class="sd">        :seealso: :func:`spatialmath.base.quaternions.qpow`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">qpow</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``=**`` operator</span>

<span class="sd">        :rtype: Quaternion instance</span>

<span class="sd">        ``q **= N`` computes the product of ``q`` with itself ``N-1`` times, where ``N`` must be</span>
<span class="sd">        an integer.  If ``N``&lt;0 the result is conjugated.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q **= 2</span>
<span class="sd">            &gt;&gt;&gt; q</span>
<span class="sd">            -28.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>

<span class="sd">            &gt;&gt;&gt; q = Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            &gt;&gt;&gt; q **= 2</span>
<span class="sd">            &gt;&gt;&gt; q</span>
<span class="sd">            -28.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            -124.000000 &lt; 60.000000, 70.000000, 80.000000 &gt;</span>

<span class="sd">        :seealso: :func:`__pow__`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<div class="viewcode-block" id="Quaternion.__truediv__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__truediv__">[docs]</a>    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># Quaternion division not supported</span></div>

<div class="viewcode-block" id="Quaternion.__add__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``+`` operator</span>

<span class="sd">        :return: sum</span>
<span class="sd">        :rtype: Quaternion, UnitQuaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ==============   ==============   ==============  ===================</span>
<span class="sd">                   Operands                            Sum</span>
<span class="sd">        -------------------------------   -----------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ===================</span>
<span class="sd">        Quaternion       Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       scalar           Quaternion      add to each element</span>
<span class="sd">        UnitQuaternion   Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      add to each element</span>
<span class="sd">        ==============   ==============   ==============  ===================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``sum = left + right``</span>
<span class="sd">         1      N       N    ``sum[i] = left + right[i]``</span>
<span class="sd">         N      1       N    ``sum[i] = left[i] + right``</span>
<span class="sd">         N      N       N    ``sum[i] = left[i] + right[i]``</span>
<span class="sd">         N      M       -    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        A scalar of length N is a list, tuple or numpy array.</span>
<span class="sd">        A 3-vector of length N is a 3xN numpy array, where each column is a 3-vector.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) + Quaternion([5,6,7,8])</span>
<span class="sd">            6.000000 &lt; 8.000000, 10.000000, 12.000000 &gt;</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) + Quaternion([1,2,3,4])</span>
<span class="sd">            2.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            6.000000 &lt; 8.000000, 10.000000, 12.000000 &gt;</span>
<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) + Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            2.000000 &lt; 4.000000, 6.000000, 8.000000 &gt;</span>
<span class="sd">            10.000000 &lt; 12.000000, 14.000000, 16.000000 &gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># results is not in the group, return an array, not a class</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s1">&#39;operands to + are of different types&#39;</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span></div>

<div class="viewcode-block" id="Quaternion.__sub__"><a class="viewcode-back" href="../../3d_quaternion.html#spatialmath.quaternion.Quaternion.__sub__">[docs]</a>    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``-`` operator</span>

<span class="sd">        :return: difference</span>
<span class="sd">        :rtype: Quaternion, UnitQuaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ==============   ==============   ==============  ==========================</span>
<span class="sd">                   Operands                          Difference</span>
<span class="sd">        -------------------------------   ------------------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ==========================</span>
<span class="sd">        Quaternion       Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        Quaternion       scalar           Quaternion      subtract from each element</span>
<span class="sd">        UnitQuaternion   Quaternion       Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   Quaternion      elementwise sum</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      subtract from each element</span>
<span class="sd">        ==============   ==============   ==============  ==========================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``diff = left - right``</span>
<span class="sd">         1      N       N    ``diff[i] = left - right[i]``</span>
<span class="sd">         N      1       N    ``diff[i] = left[i] - right``</span>
<span class="sd">         N      N       N    ``diff[i] = left[i] - right[i]``</span>
<span class="sd">         N      M       -    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        A scalar of length N is a list, tuple or numpy array.</span>
<span class="sd">        A 3-vector of length N is a 3xN numpy array, where each column is a 3-vector.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([1,2,3,4]) - Quaternion([5,6,7,8])</span>
<span class="sd">            -4.000000 &lt; -4.000000, -4.000000, -4.000000 &gt;</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) - Quaternion([1,2,3,4])</span>
<span class="sd">            0.000000 &lt; 0.000000, 0.000000, 0.000000 &gt;</span>
<span class="sd">            4.000000 &lt; 4.000000, 4.000000, 4.000000 &gt;</span>

<span class="sd">            &gt;&gt;&gt; Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]]) - Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            0.000000 &lt; 0.000000, 0.000000, 0.000000 &gt;</span>
<span class="sd">            0.000000 &lt; 0.000000, 0.000000, 0.000000 &gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># results is not in the group, return an array, not a class</span>
        <span class="c1"># TODO allow class +/- a conformant array</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)),</span> <span class="s1">&#39;operands to - are of different types&#39;</span>
        <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded unary ``-`` operator</span>

<span class="sd">        :rtype: Quaternion or UnitQuaternion</span>

<span class="sd">        ``-q`` is a quaternion with all its components negated.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; -Quaternion([1,2,3,4])</span>
<span class="sd">            -0.182574 &lt;&lt; -0.365148, -0.547723, -0.730297 &gt;&gt;</span>

<span class="sd">            &gt;&gt;&gt; -Quaternion([np.r_[1,2,3,4], np.r_[5,6,7,8]])</span>
<span class="sd">            -0.182574 &lt;&lt; -0.365148, -0.547723, -0.730297 &gt;&gt;</span>
<span class="sd">            -0.379049 &lt;&lt; -0.454859, -0.530669, -0.606478 &gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pylint: disable=invalid-unary-operand-type</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Readable representation of pose (superclass method)</span>

<span class="sd">        :return: readable representation of the pose as a list of arrays</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>

<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; q</span>
<span class="sd">            Quaternion(array([[ 1.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="sd">                       [ 0.        ,  0.95533649, -0.29552021,  0.        ],</span>
<span class="sd">                       [ 0.        ,  0.29552021,  0.95533649,  0.        ],</span>
<span class="sd">                       [ 0.        ,  0.        ,  0.        ,  1.        ]]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;([])&#39;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># need to indent subsequent lines of the native repr string by 4 spaces</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># format this as a list of ndarrays</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;([</span><span class="se">\n</span><span class="s1">  &#39;</span> <span class="o">+</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; ])&#39;</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string for IPython (superclass method)</span>

<span class="sd">        :param p: pretty printer handle (ignored)</span>
<span class="sd">        :param cycle: pretty printer flag (ignored)</span>

<span class="sd">        Print colorized output when variable is displayed in IPython, ie. on a line by</span>
<span class="sd">        itself.</span>

<span class="sd">        Example::</span>

<span class="sd">            In [1]: x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string representation of quaternion</span>

<span class="sd">        :return: readable representation of quaternion</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Format the quaternion elements into a single line format.  For example::</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import Quaternion</span>
<span class="sd">            &gt;&gt;&gt; q = Quaternion([1,2,3,4])</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            1.000000 &lt; 2.000000, 3.000000, 4.000000 &gt;</span>
<span class="sd">            &gt;&gt; q = UnitQuaternion.Rx(0.3)</span>
<span class="sd">            0.988771 &lt;&lt; 0.149438, 0.000000, 0.000000 &gt;&gt;</span>

<span class="sd">            Note that unit quaternions are denoted by different delimiters for</span>
<span class="sd">            the vector part.</span>

<span class="sd">                    :seealso: :func:`~spatialmath.base.quaternions.qnorm`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UnitQuaternion</span><span class="p">):</span>
            <span class="n">delim</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&gt;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delim</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">qprint</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="n">delim</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span></div>

<span class="c1"># ========================================================================= #</span>

<div class="viewcode-block" id="UnitQuaternion"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion">[docs]</a><span class="k">class</span> <span class="nc">UnitQuaternion</span><span class="p">(</span><span class="n">Quaternion</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unit quaternion class</span>

<span class="sd">    A unit quaternion can be considered an ordered pair :math:`(s, \vec{v})`</span>
<span class="sd">    where :math:`s \in \mathbb{R}` is the *scalar* part and :math:`\vec{v} = (v_x, v_y, v_z) \in \mathbb{R}^3`</span>
<span class="sd">    is the *vector* part and is often written as</span>

<span class="sd">    .. math:: \q = s \langle v_x, v_y, v_z \rangle</span>

<span class="sd">    and subject to a unit-length constraint :math:`s^2+v_x^2+v_y^2+v_z^2 = 1`.</span>

<span class="sd">    A unit-quaternion can be considered as a rotation :math:`\theta` about the</span>
<span class="sd">    vector :math:`\vec{v}`, so the unit quaternion can also be</span>
<span class="sd">    written as </span>
<span class="sd">    </span>
<span class="sd">    .. math:: \q = \cos \frac{\theta}{2} \sin \frac{\theta}{2} &lt;v_x v_y v_z&gt;</span>

<span class="sd">    The quaternion :math:`\q` and :math:`-\q` represent the equivalent rotation, and this is referred to</span>
<span class="sd">    as a double mapping.</span>

<span class="sd">    .. inheritance-diagram:: spatialmath.quaternion.UnitQuaternion</span>
<span class="sd">        :top-classes: collections.UserList</span>
<span class="sd">        :parts: 1</span>

<span class="sd">    The ``UnitQuaternion`` class inherits many methods from the ``Quaternion`` class</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="UnitQuaternion.__init__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion instance</span>

<span class="sd">        :arg norm: explicitly normalize the quaternion [default True]</span>
<span class="sd">        :type norm: bool</span>
<span class="sd">        :arg check: explicitly check validity of argument [default True]</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        - ``UnitQuaternion()`` constructs the identity quaternion 1&lt;0,0,0&gt;</span>
<span class="sd">        - ``UnitQuaternion(s, v)`` constructs a unit quaternion with specified</span>
<span class="sd">          real ``s`` and ``v`` vector parts. ``v`` is a 3-vector given as a</span>
<span class="sd">          list, tuple, or ndarray(3). If ``norm`` is True the resulting </span>
<span class="sd">          quaternion is normalized.</span>
<span class="sd">        - ``UnitQuaternion(v)`` constructs a unit quaternion with specified</span>
<span class="sd">          elements from ``v`` which is a 4-vector given as a list, tuple, or ndarray(4). Also known</span>
<span class="sd">          as the Euler parameters.</span>
<span class="sd">        - ``UnitQuaternion(M)`` construct a new unit quaternion with ``N`` values where ``Q`` is a Nx4 NumPy array</span>
<span class="sd">          whose rows are the quaternion in vector form</span>
<span class="sd">        - ``UnitQuaternion(R)`` constructs a unit quaternion from an SO(3)</span>
<span class="sd">          rotation matrix given as a ndarray(3,3). If ``check`` is True</span>
<span class="sd">          test the rotation submatrix for orthogonality.</span>
<span class="sd">        - ``UnitQuaternion(X)`` constructs a unit quaternion from the rotational</span>
<span class="sd">          part of ``X`` which is an SO3 or SE3 instance.  If len(X) &gt; 1 then</span>
<span class="sd">          the resulting unit quaternion is of the same length.</span>
<span class="sd">        - ``UnitQuaternion([q1, q2 .. qN])`` construct a new unit quaternion with ``N`` values where each element is a 4-vector</span>
<span class="sd">        - ``UnitQuaternion([Q1, Q2 .. QN])`` construct a new unit quaternion with ``N`` values where each element is a UnitQuaternion instance</span>
<span class="sd">        - ``UnitQuaternion([X1, X2 .. XN])`` construct a new unit quaternion with ``N`` values where each element is an SO3 or SE3 instance</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ()</span>
<span class="sd">            &gt;&gt;&gt; q         # repr()</span>
<span class="sd">            &gt;&gt;&gt; print(q)  # str()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># single argument</span>
            <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
                <span class="c1"># create unit quaternion</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># passed a NumPy array, it could be:</span>
                <span class="c1">#  an SO(3) or SE(3) matrix</span>
                <span class="c1">#  a quaternion as a 1D array</span>
                <span class="c1">#  an array of quaternions as an nx4 array</span>

                <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
                    <span class="c1"># UnitQuaternion(R) R is 3x3 rotation matrix</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
                <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
                    <span class="c1"># passed a 4-vector</span>
                    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># self.data = [base.qpositive(x) for x in s]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SO3</span><span class="p">):</span>
                <span class="c1"># UnitQuaternion(x) x is SO3 or SE3 (since SE3 is subclass of SO3)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SO3</span><span class="p">):</span>
                <span class="c1"># list of SO3 or SE3</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad argument to UnitQuaternion constructor&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># UnitQuaternion(s, v)   s is scalar, v is 3-vector</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad argument to UnitQuaternion constructor&#39;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_identity</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">eye</span><span class="p">()</span>

<div class="viewcode-block" id="UnitQuaternion.isvalid"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if vector is valid unit quaternion</span>

<span class="sd">        :param x: vector to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :arg check: explicitly check vector is unit length [default True]</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: True if the matrix has shape (4,).</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion </span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; UnitQuaternion.isvalid(np.r_[1, 0, 0, 0])</span>
<span class="sd">            &gt;&gt;&gt; UnitQuaternion.isvalid(np.r_[1, 2, 3, 4])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check</span> <span class="ow">or</span> <span class="n">base</span><span class="o">.</span><span class="n">isunitvec</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as a rotation matrix</span>

<span class="sd">        :return: equivalent rotational matrix</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        ``q.R`` returns the rotation matrix which describes the equivalent rotation. If ``len(x)`` is:</span>

<span class="sd">            - 1, return an ndarray with shape=(3,3)</span>
<span class="sd">            - N&gt;1, return ndarray with shape=(N,3,3)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q.R</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx([0.3, 0.4])</span>
<span class="sd">            &gt;&gt;&gt; q.R</span>
<span class="sd">            </span>
<span class="sd">        .. warning:: The i&#39;th rotation matrix is ``x[i,:,:]`` or simply </span>
<span class="sd">            ``x[i]``. This is different to the MATLAB version where the i&#39;th</span>
<span class="sd">            rotation matrix is ``x(:,:,i)``.        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vec3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion unique vector part</span>

<span class="sd">        :return: vector part of unit quaternion</span>
<span class="sd">        :rtype: numpy array, shape=(3,)</span>

<span class="sd">        ``q.vec3`` is the vector part of a unit quaternion.  If ``q`` has a negative scalar</span>
<span class="sd">        part we take the vector part of ``-q``, since  ``q`` and ``-q`` represent the</span>
<span class="sd">        same rotation.</span>

<span class="sd">        This vector part is a minimal unique representation of the unit quaternion and can be used in</span>
<span class="sd">        optimization procedures such as bundle adjustment.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rz(-4)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q.vec3</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Vec3(q.vec3)</span>
<span class="sd">            &gt;&gt;&gt; print(q2)</span>
<span class="sd">            &gt;&gt;&gt; q == q2</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.UnitQuaternion.Vec3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">q2v</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------- constructor variants</span>
<div class="viewcode-block" id="UnitQuaternion.Rx"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Rx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion object representing rotation about the X-axis</span>

<span class="sd">        :arg : rotation angle</span>
<span class="sd">        :type : float or array_like</span>
<span class="sd">        :arg unit: rotation unit &#39;rad&#39; [default] or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion()`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ```` radians about the X-axis.</span>
<span class="sd">        - ``UnitQuaternion(, &#39;deg&#39;)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ```` degrees about the X-axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0, 0.3, 0.6]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Ry"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Ry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Ry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion object representing rotation about the Y-axis</span>

<span class="sd">        :arg : rotation angle</span>
<span class="sd">        :type : float or array_like</span>
<span class="sd">        :arg unit: rotation unit &#39;rad&#39; [default] or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion()`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ```` radians about the Y-axis.</span>
<span class="sd">        - ``UnitQuaternion(, &#39;deg&#39;)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ```` degrees about the Y-axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Ry(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Ry([0, 0.3, 0.6]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Rz"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Rz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a UnitQuaternion object representing rotation about the Z-axis</span>

<span class="sd">        :arg : rotation angle</span>
<span class="sd">        :type : float or array_like</span>
<span class="sd">        :arg unit: rotation unit &#39;rad&#39; [default] or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion()`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ```` radians about the Z-axis.</span>
<span class="sd">        - ``UnitQuaternion(, &#39;deg&#39;)`` constructs a unit quaternion representing a</span>
<span class="sd">          rotation of ```` degrees about the Z-axis.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rz(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rz([0, 0.3, 0.6]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Rand"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Rand">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rand</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new random unit quaternion</span>

<span class="sd">        :param N: number of random rotations</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :return: random unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion.Rand()`` is a uniformly distributed random unit quaternion value.</span>
<span class="sd">        - ``SO3.Rand(N)`` is a unit quaternion instance containing a sequence of N random unit quaternion</span>
<span class="sd">          values.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rand())</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rand(3))</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.UnitQuaternion.Rand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Eul"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Eul">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from Euler angles</span>

<span class="sd">        :param : 3-vector of Euler angles</span>
<span class="sd">        :type : array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion.Eul()`` is a unit quaternion that describes the 3D</span>
<span class="sd">          rotation defined by a 3-vector of Euler angles :math:`\Gamma = (\phi,</span>
<span class="sd">          \theta, \psi)` which correspond to consecutive rotations about the Z,</span>
<span class="sd">          Y, Z axes respectively.</span>

<span class="sd">        - ``UnitQuaternion.Eul(, , )`` as above but the angles are provided</span>
<span class="sd">          as three scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Eul([0.1, 0.2, 0.3]))</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.UnitQuaternion.RPY`, :func:`~spatialmath.pose3d.SE3.eul`, :func:`~spatialmath.pose3d.SE3.Eul`, :func:`~spatialmath.base.transforms3d.eul2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.RPY"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.RPY">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from roll-pitch-yaw angles</span>

<span class="sd">        :param : 3-vector of roll-pitch-yaw angles</span>
<span class="sd">        :type : array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param unit: rotation order: &#39;zyx&#39; [default], &#39;xyz&#39;, or &#39;yxz&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``UnitQuaternion.RPY()`` is a unit quaternion that describes the 3D</span>
<span class="sd">          rotation defined by a  3-vector of roll, pitch, yaw angles</span>
<span class="sd">          :math:`\Gamma = (r, p, y)` which correspond to successive rotations</span>
<span class="sd">          about the axes specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch</span>
<span class="sd">              about the new y-axis, then by roll about the new x-axis.</span>
<span class="sd">              Convention for a mobile robot with x-axis forward and y-axis</span>
<span class="sd">              sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the</span>
<span class="sd">              new y-axis, then by roll about the new z-axis. Convention for a</span>
<span class="sd">              robot gripper with z-axis forward and y-axis between the gripper</span>
<span class="sd">              fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the</span>
<span class="sd">              new x-axis, then by roll about the new z-axis. Convention for a</span>
<span class="sd">              camera with z-axis parallel to the optic axis and x-axis parallel</span>
<span class="sd">              to the pixel rows.</span>


<span class="sd">        - ``UnitQuaternion.RPY(, , )`` as above but the angles are provided</span>
<span class="sd">          as three scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.RPY([0.1, 0.2, 0.3]))</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.UnitQuaternion.Eul`, :func:`~spatialmath.pose3d.SE3.rpy`, :func:`~spatialmath.pose3d.SE3.RPY`, :func:`~spatialmath.base.transforms3d.rpy2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.OA"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.OA">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">OA</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from two vectors</span>

<span class="sd">        :param o: 3-vector parallel to Y- axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :param a: 3-vector parallel to the Z-axis</span>
<span class="sd">        :type a: array_like</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``UnitQuaternion.OA(O, A)`` is a unit quaternion that describes the 3D rotation defined in terms of</span>
<span class="sd">        vectors parallel to the Y- and Z-axes of its reference frame.  In robotics these axes are</span>
<span class="sd">        respectively called the orientation and approach vectors defined such that</span>
<span class="sd">        R = [N O A] and N = O x A.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.OA([0,0,-1], [0,1,0]))</span>

<span class="sd">        .. notes::</span>

<span class="sd">            - Only the ``A`` vector is guaranteed to have the same direction in the resulting</span>
<span class="sd">            rotation matrix</span>
<span class="sd">            - ``O`` and ``A`` do not have to be unit-length, they are normalized</span>
<span class="sd">            - ``O`` and ``A` do not have to be orthogonal, so long as they are not parallel</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.oa2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">r2q</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">oa2r</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.AngVec"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.AngVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">AngVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from rotation angle and axis</span>

<span class="sd">        :param theta: rotation</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``UnitQuaternion.AngVec(, v)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of ```` about the 3-vector ``v``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.AngVec(0, [1,0,0]))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.AngVec(90, [1,0,0], unit=&#39;deg&#39;))</span>

<span class="sd">        .. note:: :math:`\theta = 0` the result in an identity quaternion, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.UnitQuaternion.angvec`, :func:`~spatialmath.quaternion.UnitQuaternion.exp`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getunit</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">v</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.EulerVec"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.EulerVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">EulerVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from an Euler rotation vector</span>

<span class="sd">        :param : rotation axis</span>
<span class="sd">        :type : 3-element array_like</span>
<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``UnitQuaternion.EulerVec()`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of :math:`\theta = \lVert \omega \rVert` about the</span>
<span class="sd">        unit 3-vector :math:`\omega / \lVert \omega \rVert`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.EulerVec([0.5,0,0]))</span>

<span class="sd">        .. note:: :math:`\theta \eq 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;w must be a 3-vector&#39;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">base</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.Vec3"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.Vec3">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Vec3</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new unit quaternion from its vector part</span>

<span class="sd">        :param vec: vector part of unit quaternion</span>
<span class="sd">        :type vec: 3-element array_like</span>

<span class="sd">        ``UnitQuaternion.Vec(v)`` is a new unit quaternion with the specified vector part</span>
<span class="sd">        and the scalar part is</span>
<span class="sd">        </span>
<span class="sd">        .. math:: s = \sqrt{1 - v_x^2 - v_y^2 - v_z^2}</span>
<span class="sd">        </span>
<span class="sd">        The unit quaternion will always have a positive scalar part.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rz(-4)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q.vec3</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Vec3(q.vec3)</span>
<span class="sd">            &gt;&gt;&gt; print(q2)</span>
<span class="sd">            &gt;&gt;&gt; q == q2</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.UnitQuaternion.vec3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">v2q</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span></div>

<div class="viewcode-block" id="UnitQuaternion.inv"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of unit quaternion</span>

<span class="sd">        :return: unit-quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        ``q.inv()`` is the inverse of the unit-quaternion.  This is a group operation</span>
<span class="sd">        and the product of the unit-quaternion and its inverse is the identity quaternion.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternio</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3).inv())</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3).inv() * UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]).inv())</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="UnitQuaternion.qvmul"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.qvmul">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">qvmul</span><span class="p">(</span><span class="n">qv1</span><span class="p">,</span> <span class="n">qv2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply unit quaternions defined by unique vector parts</span>

<span class="sd">        :param qv1: vector representation of first multiplicand</span>
<span class="sd">        :type qv1: ndarray(3)</span>
<span class="sd">        :param qv1: vector representation of second multiplicand</span>
<span class="sd">        :type qv1: ndarray(3)</span>

<span class="sd">        ``UnitQuaternion(qv1, qv2)`` is the Hamilton product of two unit quaternions</span>
<span class="sd">        represented in minimal vector form.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Ry(-0.3)</span>
<span class="sd">            &gt;&gt;&gt; qv1 = q1.vec3</span>
<span class="sd">            &gt;&gt;&gt; qv1</span>
<span class="sd">            &gt;&gt;&gt; qv2 = q2.vec3</span>
<span class="sd">            &gt;&gt;&gt; qv = UQ.qvmul(qv1, qv2)</span>
<span class="sd">            &gt;&gt;&gt; qv</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Vec3(qv))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Ry(-0.3))</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.UnitQuaternion.vec3`, :func:`~spatialmath.quaternion.UnitQuaternion.Vec3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">vvmul</span><span class="p">(</span><span class="n">qv1</span><span class="p">,</span> <span class="n">qv2</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.dot"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rate of change of a unit quaternion in world frame</span>

<span class="sd">        :param : angular velocity in world frame</span>
<span class="sd">        :type : 3-element array_like</span>
<span class="sd">        :return: rate of change of unit quaternion</span>
<span class="sd">        :rtype: ndarray(4)</span>

<span class="sd">        ``q.dot()`` is the rate of change of the elements of the unit quaternion ``q``</span>
<span class="sd">        which represents the orientation of a body frame with angular velocity ```` in</span>
<span class="sd">        the world frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.dotb"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.dotb">[docs]</a>    <span class="k">def</span> <span class="nf">dotb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rate of change of a unit quaternion in body frame</span>

<span class="sd">        :param : angular velocity in body frame</span>
<span class="sd">        :type : 3-element array_like</span>
<span class="sd">        :return: rate of change of unit quaternion</span>
<span class="sd">        :rtype: ndarray(4)</span>

<span class="sd">        ``q.dotb()`` is the rate of change of the elements of the unit quaternion ``q``</span>
<span class="sd">        which represents the orientation of a body frame with angular velocity ```` in</span>
<span class="sd">        the body frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">dotb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.__mul__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply unit quaternion</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: Quaternion, UnitQuaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">                   Multiplicands                   Product</span>
<span class="sd">        -------------------------------   --------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ================</span>
<span class="sd">        UnitQuaternion   Quaternion       Quaternion      Hamilton product</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   UnitQuaternion  Hamilton product</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      scalar product</span>
<span class="sd">        UnitQuaternion   3-vector         3-vector        vector rotation</span>
<span class="sd">        UnitQuaternion   3xN array        3xN array       vector rotations</span>
<span class="sd">        ==============   ==============   ==============  ================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Rx(0.4))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * 2)</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * [1, 2, 3])</span>

<span class="sd">        Note that left and right can have a length greater than 1 in which case:</span>

<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">        left   right   len     operation</span>
<span class="sd">        ====   =====   ====  ================================</span>
<span class="sd">         1      1       1    ``prod = left * right``</span>
<span class="sd">         1      N       N    ``prod[i] = left * right[i]``</span>
<span class="sd">         N      1       N    ``prod[i] = left[i] * right``</span>
<span class="sd">         N      N       N    ``prod[i] = left[i] * right[i]``</span>
<span class="sd">         N      M       n/a    ``ValueError``</span>
<span class="sd">        ====   =====   ====  ================================</span>

<span class="sd">        A scalar of length N is a list, tuple or numpy array.</span>
<span class="sd">        A 3-vector of length N is a 3xN numpy array, where each column is </span>
<span class="sd">        a 3-vector.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Rx(0.4))</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q *= UQ.Rx(0.4))</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) * UQ.Rx([0.4, 0.6])</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) * UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) * UQ.Rx([0.3, 0.6]))</span>

<span class="sd">        :seealso: :func:`~spatialmath.Quaternion.__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="c1"># quaternion * quaternion case (same class)</span>
            <span class="k">return</span> <span class="n">right</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">qqmul</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># quaternion * scalar case</span>
            <span class="c1">#print(&#39;scalar * quat&#39;)</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">([</span><span class="n">right</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">_A</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">left</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># unit quaternion * vector</span>
            <span class="c1">#print(&#39;*: pose x array&#39;)</span>
            <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># pose x vector</span>
                    <span class="c1">#print(&#39;*: pose x vector&#39;)</span>
                    <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">qvmul</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="c1"># pose array x vector</span>
                    <span class="c1">#print(&#39;*: pose array x vector&#39;)</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">qvmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">_A</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># pose x stack of vectors</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">qvmul</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">right</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad operands&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UnitQuaternion: operands to * are of different types&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply unit quaternion in place</span>

<span class="sd">        :return: product</span>
<span class="sd">        :rtype: UnitQuaternion, Quaternion</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        Multiplies a quaternion in place. If the right operand is a list,</span>
<span class="sd">        the result will be a list.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q *= UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q</span>
<span class="sd">            0.955336 &lt;&lt; 0.295520, 0.000000, 0.000000 &gt;&gt;</span>

<span class="sd">        :seealso: :func:`__mul__`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<div class="viewcode-block" id="UnitQuaternion.__truediv__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__truediv__">[docs]</a>    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``/`` operator</span>

<span class="sd">        :rtype: Quaternion or UnitQuaternion</span>

<span class="sd">        - ``q1 / q2`` is equivalent to ``q1 * q1.inv()``.</span>
<span class="sd">        - ``q / s`` performs elementwise division of the elements of ``q`` by </span>
<span class="sd">          ``s``. This is not a group operation so the result will be a </span>
<span class="sd">          Quaternion.</span>

<span class="sd">        ==============   ==============   ==============  ===========================</span>
<span class="sd">                   Multiplicands                   Quotient</span>
<span class="sd">        -------------------------------   -------------------------------------------</span>
<span class="sd">            left             right            type           result</span>
<span class="sd">        ==============   ==============   ==============  ===========================</span>
<span class="sd">        UnitQuaternion   UnitQuaternion   UnitQuaternion  Hamilton product by inverse</span>
<span class="sd">        UnitQuaternion   scalar           Quaternion      element-wise division</span>
<span class="sd">        ==============   ==============   ==============  ===========================</span>

<span class="sd">        Any other input combinations result in a ValueError.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / 2)</span>

<span class="sd">        For pose composition either or both operands may hold more than one value which</span>
<span class="sd">        results in the composition holding more than one value according to:</span>

<span class="sd">        =========   ==========   ====  =====================================</span>
<span class="sd">        len(left)   len(right)   len     operation</span>
<span class="sd">        =========   ==========   ====  =====================================</span>
<span class="sd">         1          1             1    ``quo = left * right.inv()``</span>
<span class="sd">         1          M             M    ``quo[i] = left * right[i].inv()``</span>
<span class="sd">         N          1             M    ``quo[i] = left[i] * right.inv()``</span>
<span class="sd">         M          M             M    ``quo[i] = left[i] * right[i].inv()``</span>
<span class="sd">        =========   ==========   ====  =====================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) / UQ.Rx(0.3))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx(0.3) / UQ.Rx([0.3, 0.6]))</span>
<span class="sd">            &gt;&gt;&gt; print(UQ.Rx([0.3, 0.6]) / UQ.Rx([0.3, 0.6]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">qqmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">y</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad operands&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.__eq__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``==`` operator</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        ``q1 == q2`` is True if ``q1`` is elementwise equal to ``q2`` and accounts for the</span>
<span class="sd">        double mapping. Supports broadcasting.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q1 == q1</span>
<span class="sd">            &gt;&gt;&gt; q1 == (-q1)</span>
<span class="sd">            &gt;&gt;&gt; q1 == q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q1</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == UQ([q1, q2])</span>

<span class="sd">        :seealso: :func:`__ne__`, :func:`~spatialmath.base.quaternions.isequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">isequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unitq</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.__ne__"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.__ne__">[docs]</a>    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded ``!=`` operator</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        ``q1 != q2`` is True if ``q1`` is elementwise not equal to ``q2`` and accounts for the</span>
<span class="sd">        double mapping. Supports broadcasting.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UQ.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q1 != q1</span>
<span class="sd">            &gt;&gt;&gt; q1 != (-q1)</span>
<span class="sd">            &gt;&gt;&gt; q1 != q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q1</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == q2</span>
<span class="sd">            &gt;&gt;&gt; UQ([q1, q2]) == UQ([q1, q2])</span>

<span class="sd">        :seealso: :func:`__eq__`, :func:`~spatialmath.base.quaternions.isequal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">not</span> <span class="n">base</span><span class="o">.</span><span class="n">isequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unitq</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">list1</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>  <span class="c1"># lgtm[py/not-named-self] pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded @ operator</span>

<span class="sd">        :return: product :rtype: UnitQuaternion</span>

<span class="sd">        - ``q1 @ q2`` is the Hamilton product of ``q1`` and ``q2``, both unit</span>
<span class="sd">          quaternions, followed by explicit normalization.</span>

<span class="sd">        - `` q1 @= q2`` as above.</span>

<span class="sd">        .. note:: This operator is functionally equivalent to ``*`` but is more</span>
<span class="sd">            costly.  It is useful for cases where a pose is incrementally update</span>
<span class="sd">            over many cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">qqmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))))</span>

<div class="viewcode-block" id="UnitQuaternion.interp"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.interp">[docs]</a>    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate between two unit quaternions</span>

<span class="sd">        :param end: final unit quaternion</span>
<span class="sd">        :type end: UnitQuaternion</span>
<span class="sd">        :param shortest: Take the shortest path along the great circle</span>
<span class="sd">        :param s: interpolation coefficient, range 0 to 1, or number of steps</span>
<span class="sd">        :type s: array_like or int</span>
<span class="sd">        :return: interpolated unit quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``q0.interp(q1, s)`` is a unit quaternion that is interpolated between</span>
<span class="sd">          ``q0`` when s=0 and ``q1`` when s=1. Spherical linear interpolation</span>
<span class="sd">          (slerp) is used.  If ``s`` is an ndarray(n) then the result will be</span>
<span class="sd">          a UnitQuaternion with n values.</span>

<span class="sd">        - ``q0.interp(q1, N)`` interpolate between ``q0`` and ``q1`` in ``N``</span>
<span class="sd">          steps.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q1 = UQ.Rx(0.3); q2 = UQ.Rz(-0.4)</span>
<span class="sd">            &gt;&gt;&gt; print(q1)</span>
<span class="sd">            &gt;&gt;&gt; print(q2)</span>
<span class="sd">            &gt;&gt;&gt; q1.interp(q2, 0)    # this is q1</span>
<span class="sd">            &gt;&gt;&gt; q1.interp(q2, 1,)   # this is q2</span>
<span class="sd">            &gt;&gt;&gt; q1.interp(q2, 0.5)  # this is in between</span>
<span class="sd">            &gt;&gt;&gt; q = q1.interp(q2, 11)  # in 11 steps</span>
<span class="sd">            &gt;&gt;&gt; len(q)</span>
<span class="sd">            &gt;&gt;&gt; q[0]                # this is q1</span>
<span class="sd">            &gt;&gt;&gt; q[5]                # this is in between</span>

<span class="sd">        .. note:: values of ``s`` are silently clipped to the range [0, 1]</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.slerp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO allow self to have len() &gt; 1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># enforce valid values</span>

        <span class="c1"># 2 quaternion form</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">UnitQuaternion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;end argument must be a UnitQuaternion&#39;</span><span class="p">)</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">vec</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span>

        <span class="c1"># If the dot product is negative, the quaternions</span>
        <span class="c1"># have opposite handed-ness and slerp won&#39;t take</span>
        <span class="c1"># the shorter path. Fix by reversing one quaternion.</span>
        <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q1</span> <span class="o">=</span> <span class="o">-</span> <span class="n">q1</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span>

        <span class="c1"># shouldn&#39;t be needed by handle numerical errors: -eps, 1+eps cases</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Clip within domain of acos()</span>

        <span class="n">theta_0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">)</span>  <span class="c1"># theta_0 = angle between input vectors</span>

        <span class="n">qi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_0</span> <span class="o">*</span> <span class="n">sk</span>  <span class="c1"># theta = angle between v0 and result</span>

            <span class="n">s1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">))</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">q1</span> <span class="o">*</span> <span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q2</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>
            <span class="n">qi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.interp1"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.interp1">[docs]</a>    <span class="k">def</span> <span class="nf">interp1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a unit quaternions</span>

<span class="sd">        :param shortest: Take the shortest path along the great circle</span>
<span class="sd">        :param s: interpolation coefficient, range 0 to 1, or number of steps</span>
<span class="sd">        :type s: array_like or int</span>
<span class="sd">        :return: interpolated unit quaternion</span>
<span class="sd">        :rtype: UnitQuaternion instance</span>

<span class="sd">        - ``q.interp1(s)`` is a unit quaternion that is interpolated between</span>
<span class="sd">          identity when s=0 and ``q`` when s=1. Spherical linear interpolation</span>
<span class="sd">          (slerp) is used.  If ``s`` is an ndarray(n) then the result will be</span>
<span class="sd">          a UnitQuaternion with n values.</span>

<span class="sd">        - ``q.interp1(N)`` interpolate between identity and ``q1`` in ``N``</span>
<span class="sd">          steps.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>
<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(q)</span>
<span class="sd">            &gt;&gt;&gt; q.interp1(0)    # this is identity</span>
<span class="sd">            &gt;&gt;&gt; q.interp1(1)    # this is q</span>
<span class="sd">            &gt;&gt;&gt; q.interp1(0.5)  # this is in between</span>
<span class="sd">            &gt;&gt;&gt; qi = q.interp1(q2, 11)  # in 11 steps</span>
<span class="sd">            &gt;&gt;&gt; len(qi)</span>
<span class="sd">            &gt;&gt;&gt; qi[0]                # this is q1</span>
<span class="sd">            &gt;&gt;&gt; qi[5]                # this is in between</span>

<span class="sd">        .. note:: values of ``s`` are silently clipped to the range [0, 1]</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.quaternions.slerp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO allow self to have len() &gt; 1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># enforce valid values</span>

        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># s</span>

        <span class="c1"># If the dot product is negative, the quaternions</span>
        <span class="c1"># have opposite handed-ness and slerp won&#39;t take</span>
        <span class="c1"># the shorter path. Fix by reversing one quaternion.</span>
        <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="o">-</span> <span class="n">q</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span>

        <span class="c1"># shouldn&#39;t be needed by handle numerical errors: -eps, 1+eps cases</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Clip within domain of acos()</span>

        <span class="n">theta_0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">)</span>  <span class="c1"># theta_0 = angle between input vectors</span>

        <span class="n">qi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_0</span> <span class="o">*</span> <span class="n">sk</span>  <span class="c1"># theta = angle between v0 and result</span>

            <span class="n">s1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">))</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>
            <span class="n">qi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.increment"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.increment">[docs]</a>    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quaternion incremental update</span>

<span class="sd">        :param w: angular displacement, Euler vector</span>
<span class="sd">        :type w: array_like(3)</span>
<span class="sd">        :param normalize: normalize the result, defaults to False</span>
<span class="sd">        :type normalize: bool, optional</span>

<span class="sd">        .. note:: The object state is updated</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># is (v, theta) or None</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">unitvec_norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># zero update</span>
            <span class="k">return</span>
    
        <span class="n">ds</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span>

        <span class="n">updated</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">qqmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ds</span><span class="p">,</span> <span class="n">dv</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">updated</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">updated</span><span class="p">]</span></div>

<div class="viewcode-block" id="UnitQuaternion.plot"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot unit quaternion as a coordinate frame</span>

<span class="sd">        :param `**kwargs`: plotting options</span>

<span class="sd">        - ``q.plot()`` displays the orientation ``q`` as a coordinate frame in 3D.</span>
<span class="sd">          There are many options, see the links below.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; q = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q.plot(frame=&#39;A&#39;, color=&#39;green&#39;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trplot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span><span class="o">.</span><span class="n">trplot</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.animate"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.animate">[docs]</a>    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot unit quaternion as an animated coordinate frame</span>

<span class="sd">        :param start: initial pose, defaults to null/identity</span>
<span class="sd">        :type start: UnitQuaternion</span>
<span class="sd">        :param `**kwargs`: plotting options</span>

<span class="sd">        - ``q.animate()`` displays the orientation ``q`` as a coordinate frame moving</span>
<span class="sd">          from the origin in either 3D.  There are </span>
<span class="sd">          many options, see the links below.</span>
<span class="sd">        - ``q.animate(*args, start=q1)`` displays the orientation ``q`` as a coordinate</span>
<span class="sd">          frame moving from orientation ``q11``, in 3D.  There are </span>
<span class="sd">          many options, see the links below.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; X = UQ.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; X.animate(frame=&#39;A&#39;, color=&#39;green&#39;)</span>
<span class="sd">            &gt;&gt;&gt; X.animate(start=UQ.Ry(0.2))</span>

<span class="sd">        :see :func:`~spatialmath.base.transforms3d.tranimate`, :func:`~spatialmath.base.transforms3d.trplot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">base</span><span class="o">.</span><span class="n">tranimate</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span><span class="o">.</span><span class="n">tranimate</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.rpy"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.rpy">[docs]</a>    <span class="k">def</span> <span class="nf">rpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as roll-pitch-yaw angles</span>

<span class="sd">        :param order: angle sequence order, default to &#39;zyx&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of roll-pitch-yaw angles</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        ``q.rpy`` is the roll-pitch-yaw angle representation of the 3D rotation.  The angles are</span>
<span class="sd">        a 3-vector :math:`(r, p, y)` which correspond to successive rotations about the axes</span>
<span class="sd">        specified by ``order``:</span>

<span class="sd">            - &#39;zyx&#39; [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - &#39;xyz&#39;, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - &#39;yxz&#39;, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        If ``len(x)`` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(N,3)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>

<span class="sd">            &gt;&gt;&gt; UQ.Rx(0.3).rpy()</span>
<span class="sd">            array([ 0.3, -0. ,  0. ])</span>
<span class="sd">            &gt;&gt;&gt; UQ.Rz([0.2, 0.3]).rpy()</span>
<span class="sd">            array([[ 0. , -0. ,  0.2],</span>
<span class="sd">                [ 0. , -0. ,  0.3]])</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.RPY`, ::func:`spatialmath.base.transforms3d.tr2rpy`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="UnitQuaternion.eul"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.eul">[docs]</a>    <span class="k">def</span> <span class="nf">eul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as Euler angles</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of Euler angles</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        ``q.eul`` is the Euler angle representation of the rotation.  Euler angles are</span>
<span class="sd">        a 3-vector :math:`(\phi, \theta, \psi)` which correspond to consecutive</span>
<span class="sd">        rotations about the Z, Y, Z axes respectively.</span>

<span class="sd">        If ``len(x)`` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(N,3)</span>

<span class="sd">        - ndarray with shape=(3,), if len(R) == 1</span>
<span class="sd">        - ndarray with shape=(N,3), if len(R) = N &gt; 1</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>

<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).eul()</span>
<span class="sd">            array([0. , 0. , 0.3])</span>
<span class="sd">            &gt;&gt;&gt; UQ.Ry([0.3, 0.4]).eul()</span>
<span class="sd">            array([[0. , 0.3, 0. ],</span>
<span class="sd">                [0. , 0.4, 0. ]])</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.Eul`, ::func:`spatialmath.base.transforms3d.tr2eul`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="UnitQuaternion.angvec"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.angvec">[docs]</a>    <span class="k">def</span> <span class="nf">angvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as angle and rotation vector</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param check: check that rotation matrix is valid</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: :math:`(\theta, {\bf v})`</span>
<span class="sd">        :rtype: float, ndarray(3)</span>

<span class="sd">        ``q.angvec()`` is a tuple :math:`(\theta, v)` containing the rotation </span>
<span class="sd">        angle and a rotation axis which is equivalent to the rotation of</span>
<span class="sd">        the unit quaternion ``q``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>

<span class="sd">        &gt;&gt;&gt; UQ.Rz(0.3).angvec()</span>
<span class="sd">            (0.3, array([0., 0., 1.]))</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.AngVec`, :func:`~spatialmath.quaternion.UnitQuaternion.log`, :func:`~angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2angvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>

    <span class="c1"># def log(self):</span>
    <span class="c1">#     r&quot;&quot;&quot;</span>
    <span class="c1">#     Logarithm of unit quaternion</span>

    <span class="c1">#     :rtype: Quaternion instance</span>

    <span class="c1">#     ``q.log()`` is the logarithm of the unit quaternion ``q``, ie.</span>
        
    <span class="c1">#     .. math::</span>
        
    <span class="c1">#          0  \langle \frac{\mathb{v}}{\| \mathbf{v} \|} \acos s \rangle</span>

    <span class="c1">#     Example:</span>

    <span class="c1">#     .. runblock:: pycon</span>

    <span class="c1">#         &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
    <span class="c1">#         &gt;&gt;&gt; q = UnitQuaternion.Rx(0.3)</span>
    <span class="c1">#         &gt;&gt;&gt; print(q.log())</span>

    <span class="c1">#     :reference: `Wikipedia &lt;https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions&gt;`_</span>

    <span class="c1">#     :seealso: :func:`~spatialmath.quaternion.Quaternion.log`, `~spatialmath.quaternion.Quaternion.exp`</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return Quaternion(s=0, v=math.acos(self.s) * base.unitvec(self.v))</span>

<div class="viewcode-block" id="UnitQuaternion.angdist"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.angdist">[docs]</a>    <span class="k">def</span> <span class="nf">angdist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angular distance metric between unit quaternions</span>

<span class="sd">        :param other: second unit quaternion</span>
<span class="sd">        :type other: UnitQuaternion instance</span>
<span class="sd">        :param metric: metric, default is 3</span>
<span class="sd">        :type metric: int</span>
<span class="sd">        :raises TypeError: if other is not a UnitQuaternion</span>
<span class="sd">        :return: angle in radians</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ``q1.angdist(q2)`` is the geodesic norm, or geodesic distance between two</span>
<span class="sd">        unit quaternions.  We can consider it as the angle between two quaternions.</span>

<span class="sd">        Several metrics are supported:</span>

<span class="sd">        ======   ===============================================================</span>
<span class="sd">        Metric   Details</span>
<span class="sd">        ======   ===============================================================</span>
<span class="sd">        0        :math:`1 - | \q_1 \bullet \q_2 | \in [0, 1]`</span>
<span class="sd">        1        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        2        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        3        :math:`2 \tan^{-1} \| \q_1 \pm \q_2\| / \|\q_1 \mp \q_2\| \in [0, \pi/2]`</span>
<span class="sd">        4        :math:`\cos^{-1} \left( 2 (\q_1 \bullet \q_2)^2 - 1\right) \in [0, 1]`</span>
<span class="sd">        ======   ===============================================================</span>

<span class="sd">        Metric 3 computes the sum and difference of the quaternions and uses</span>
<span class="sd">        the largest value in the denominator.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; q1 = UnitQuaternion.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; q2 = UnitQuaternion.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(q1.angdist(q1))</span>
<span class="sd">            &gt;&gt;&gt; print(q1.angdist(q2))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - metrics 1, 2, 4 can throw ValueError &quot;math domain error&quot; due to</span>
<span class="sd">              numeric errors which push the argument of ``acos()`` marginally</span>
<span class="sd">              outside its domain [0, 1].</span>
<span class="sd">            - metrics 2 and 3 are equivalent, but 3 is more robust</span>
<span class="sd">            - SMTB-MATLAB uses metric 3 for UnitQuaternion.angle()</span>
<span class="sd">            - MATLAB&#39;s quaternion.dist() uses metric 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">UnitQuaternion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bad operand&#39;</span><span class="p">)</span>



        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span>  <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span>  <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">metric3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span>  <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span>  <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>

            <span class="n">measure</span> <span class="o">=</span>  <span class="n">metric3</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.SO3"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.SO3">[docs]</a>    <span class="k">def</span> <span class="nf">SO3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as SO3 instance</span>

<span class="sd">        :return: an SO(3) representation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``q.SO3()`` is an ``SO3`` instance representing the same rotation </span>
<span class="sd">        as the unit quaternion ``q``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>

<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).SO3()</span>
<span class="sd">            SO3(array([[ 0.95533649, -0.29552021,  0.        ],</span>
<span class="sd">                    [ 0.29552021,  0.95533649,  0.        ],</span>
<span class="sd">                    [ 0.        ,  0.        ,  1.        ]]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SO3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitQuaternion.SE3"><a class="viewcode-back" href="../../3d_orient_unitquaternion.html#spatialmath.quaternion.UnitQuaternion.SE3">[docs]</a>    <span class="k">def</span> <span class="nf">SE3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit quaternion as SE3 instance</span>

<span class="sd">        :return: an SE(3) representation</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``q.SE3()`` is an ``SE3`` instance representing the same rotation </span>
<span class="sd">        as the unit quaternion ``q`` and with zero translation.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion as UQ</span>

<span class="sd">            &gt;&gt;&gt; UQ.Rz(0.3).SE3()</span>
<span class="sd">            SE3(array([[ 0.95533649, -0.29552021,  0.        ,  0.        ],</span>
<span class="sd">                    [ 0.29552021,  0.95533649,  0.        ,  0.        ],</span>
<span class="sd">                    [ 0.        ,  0.        ,  1.        ,  0.        ],</span>
<span class="sd">                    [ 0.        ,  0.        ,  0.        ,  1.        ]]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SE3</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">r2t</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

    <span class="kn">import</span> <span class="nn">pathlib</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">UnitQuaternion</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">exec</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;tests&quot;</span> <span class="o">/</span> <span class="s2">&quot;test_quaternion.py&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>  <span class="c1"># pylint: disable=exec-used</span>







</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Peter Corke.
      <span class="lastupdated">Last updated on 04-Nov-2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>