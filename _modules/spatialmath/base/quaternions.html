<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spatialmath.base.quaternions &mdash; Spatial Maths package  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Spatial Maths package
            <img src="../../../_static/CartesianSnakes_LogoW.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spatialmath.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functions.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../indices.html">Indices</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Spatial Maths package</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spatialmath.base.quaternions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spatialmath.base.quaternions</h1><div class="highlight"><pre>
<span></span><span class="c1"># Part of Spatial Math Toolbox for Python</span>
<span class="c1"># Copyright (c) 2000 Peter Corke</span>
<span class="c1"># MIT Licence, see details in top-level file: LICENCE</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">These functions create and manipulate quaternions or unit quaternions.</span>
<span class="sd">The quaternion is represented</span>
<span class="sd">by a 1D NumPy array with 4 elements: s, x, y, z.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=invalid-name</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">base</span>

<span class="n">_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


<div class="viewcode-block" id="qeye"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qeye">[docs]</a><span class="k">def</span> <span class="nf">qeye</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an identity quaternion</span>

<span class="sd">    :return: an identity quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    Creates an identity quaternion, with the scalar part equal to one, and</span>
<span class="sd">    a zero vector value.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qeye, qprint</span>
<span class="sd">        &gt;&gt;&gt; q = qeye()</span>
<span class="sd">        &gt;&gt;&gt; qprint(q)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="qpure"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qpure">[docs]</a><span class="k">def</span> <span class="nf">qpure</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a pure quaternion</span>

<span class="sd">    :arg v: 3D vector</span>
<span class="sd">    :type v: array_like(3)</span>
<span class="sd">    :return: pure quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    Creates a pure quaternion, with a zero scalar value and the vector part</span>
<span class="sd">    equal to the passed vector value.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import pure, qprint</span>
<span class="sd">        &gt;&gt;&gt; q = qpure([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; qprint(q)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span></div>


<div class="viewcode-block" id="qpositive"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qpositive">[docs]</a><span class="k">def</span> <span class="nf">qpositive</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion with positive scalar part</span>

<span class="sd">    :arg q: quaternion</span>
<span class="sd">    :type v: : ndarray(4)</span>
<span class="sd">    :return: pure quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    If the scalar part is negative return -q.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q</span></div>


<div class="viewcode-block" id="qnorm"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qnorm">[docs]</a><span class="k">def</span> <span class="nf">qnorm</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Norm of a quaternion</span>

<span class="sd">    :arg q: quaternion</span>
<span class="sd">    :type v: : array_like(4)</span>
<span class="sd">    :return: norm of the quaternion</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    Returns the norm (length or magnitude) of the input quaternion which is</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>

<span class="sd">        (s^2 + v_x^2 + v_y^2 + v_z^2)^{1/2}</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qnorm</span>
<span class="sd">        &gt;&gt;&gt; q = qnorm([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; print(q)</span>

<span class="sd">    :seealso: :func:`qunit`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span></div>


<div class="viewcode-block" id="qunit"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qunit">[docs]</a><span class="k">def</span> <span class="nf">qunit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a unit quaternion</span>

<span class="sd">    :arg v: quaterion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :return: a pure quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>
<span class="sd">    :raises ValueError: quaternion has (near) zero norm</span>

<span class="sd">    Creates a unit quaternion, with unit norm, by scaling the input quaternion.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qunit, qprint</span>
<span class="sd">        &gt;&gt;&gt; q = qunit([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; qprint(q)</span>

<span class="sd">    .. note:: Scalar part is always positive.</span>

<span class="sd">    .. note:: If the quaternion norm is less than ``tol * eps`` an exception is</span>
<span class="sd">              raised.</span>

<span class="sd">    :seealso: :func:`qnorm`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">_eps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot normalize (near) zero length quaternion&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">/=</span> <span class="n">nm</span>

    <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">q</span></div>
    <span class="c1"># return q</span>


<div class="viewcode-block" id="qisunit"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qisunit">[docs]</a><span class="k">def</span> <span class="nf">qisunit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if quaternion has unit length</span>

<span class="sd">    :param v: quaternion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :param tol: tolerance in units of eps</span>
<span class="sd">    :type tol: float</span>
<span class="sd">    :return: whether quaternion has unit length</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qeye, qpure, qisunit</span>
<span class="sd">        &gt;&gt;&gt; q = qeye()</span>
<span class="sd">        &gt;&gt;&gt; qisunit(q)</span>
<span class="sd">        &gt;&gt;&gt; q = qpure([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; qisunit(q)</span>

<span class="sd">    :seealso: :func:`qunit`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">iszerovec</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span></div>


<div class="viewcode-block" id="qisequal"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qisequal">[docs]</a><span class="k">def</span> <span class="nf">qisequal</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">unitq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if quaternions are equal</span>

<span class="sd">    :param q1: quaternion</span>
<span class="sd">    :type q1: array_like(4)</span>
<span class="sd">    :param q2: quaternion</span>
<span class="sd">    :type q2: array_like(4)</span>
<span class="sd">    :param unitq: quaternions are unit quaternions</span>
<span class="sd">    :type unitq: bool</span>
<span class="sd">    :param tol: tolerance in units of eps</span>
<span class="sd">    :type tol: float</span>
<span class="sd">    :return: whether quaternions are equal</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    Tests if two quaternions are equal.</span>

<span class="sd">    For unit-quaternions ``unitq=True`` the double mapping is taken into account,</span>
<span class="sd">    that is ``q`` and ``-q`` represent the same orientation and ``isequal(q, -q, unitq=True)`` will</span>
<span class="sd">    return ``True``.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qisequal</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; q2 = [-1, -2, -3, -4]</span>
<span class="sd">        &gt;&gt;&gt; qisequal(q1, q2)</span>
<span class="sd">        &gt;&gt;&gt; qisequal(q1, q2, unitq=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unitq</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q1</span> <span class="o">-</span> <span class="n">q2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">_eps</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q1</span> <span class="o">+</span> <span class="n">q2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">_eps</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q1</span> <span class="o">-</span> <span class="n">q2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">_eps</span></div>


<div class="viewcode-block" id="q2v"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.q2v">[docs]</a><span class="k">def</span> <span class="nf">q2v</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert unit-quaternion to 3-vector</span>

<span class="sd">    :arg q: unit-quaternion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :return: a unique 3-vector</span>
<span class="sd">    :rtype: ndarray(3)</span>

<span class="sd">    Returns a unique 3-vector representing the input unit-quaternion. The sign</span>
<span class="sd">    of the scalar part is made positive, if necessary by multiplying the</span>
<span class="sd">    entire quaternion by -1, then the vector part is taken.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import q2v</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q = [1 / sqrt(2), 0, 1 / sqrt(2), 0]</span>
<span class="sd">        &gt;&gt;&gt; print(q2v(q))</span>
<span class="sd">        &gt;&gt;&gt; q = [-1 / sqrt(2), 0, 1 / sqrt(2), 0]</span>
<span class="sd">        &gt;&gt;&gt; print(q2v(q))</span>

<span class="sd">    .. warning:: There is no check that the passed value is a unit-quaternion.</span>

<span class="sd">    :seealso: :func:`v2q`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span></div>


<div class="viewcode-block" id="v2q"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.v2q">[docs]</a><span class="k">def</span> <span class="nf">v2q</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert 3-vector to unit-quaternion</span>

<span class="sd">    :arg v: vector part of unit quaternion</span>
<span class="sd">    :type v: array_like(3)</span>
<span class="sd">    :return: a unit quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    Returns a unit-quaternion reconsituted from just its vector part.  Assumes</span>
<span class="sd">    that the scalar part was positive, so :math:`s = \sqrt{1-||v||}`.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import v2q, qprint</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; v = [0, 1 / sqrt(2), 0]</span>
<span class="sd">        &gt;&gt;&gt; qprint(v2q(v))</span>
<span class="sd">        &gt;&gt;&gt; v = [0, -1 / sqrt(2), 0]</span>
<span class="sd">        &gt;&gt;&gt; qprint(v2q(v))</span>

<span class="sd">    .. warning:: There is no check that the value is the vector part of</span>
<span class="sd">                 a unit-quaternion, and this can lead to a math domain error.</span>

<span class="sd">    :seealso: :func:`q2v`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span></div>


<div class="viewcode-block" id="qqmul"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qqmul">[docs]</a><span class="k">def</span> <span class="nf">qqmul</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion multiplication</span>

<span class="sd">    :arg q0: left-hand quaternion</span>
<span class="sd">    :type q0: : array_like(4)</span>
<span class="sd">    :arg q1: right-hand quaternion</span>
<span class="sd">    :type q1: array_like(4)</span>
<span class="sd">    :return: quaternion product</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    This is the quaternion or Hamilton product.  If both operands are unit-quaternions then</span>
<span class="sd">    the product will be a unit-quaternion.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qqmul</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; q2 = [5, 6, 7, 8]</span>
<span class="sd">        &gt;&gt;&gt; qqmul(q1, q2)    # conventional Hamilton product</span>

<span class="sd">    :seealso: qvmul, qinner, vvmul</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">q2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">q2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="n">s1</span> <span class="o">*</span> <span class="n">v2</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span></div>


<div class="viewcode-block" id="qinner"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qinner">[docs]</a><span class="k">def</span> <span class="nf">qinner</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion inner product</span>

<span class="sd">    :arg q0: quaternion</span>
<span class="sd">    :type q0: : array_like(4)</span>
<span class="sd">    :arg q1: uaternion</span>
<span class="sd">    :type q1: array_like(4)</span>
<span class="sd">    :return: inner product</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    This is the inner or dot product of two quaternions, it is the sum of the element-wise</span>
<span class="sd">    product.</span>

<span class="sd">    - The inner product ``inner(q, q)`` is the square of the norm of ``q``.</span>
<span class="sd">    - If ``q0`` and ``q1`` are unit quaternions then the inner product is the</span>
<span class="sd">      cosine of the angle between the two orientations.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qinner</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt, acos, pi</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; qinner(q1, q1)                     # square of the norm</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1/sqrt(2), 1/sqrt(2), 0, 0]  # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; q2 = [1/sqrt(2), 0, 1/sqrt(2), 0]  # 90deg rotation about y-axis</span>
<span class="sd">        &gt;&gt;&gt; acos(qinner(q1, q2)) * 180 / pi    # angle between q1 and q2</span>

<span class="sd">    :seealso: qvmul</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span></div>


<div class="viewcode-block" id="qvmul"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qvmul">[docs]</a><span class="k">def</span> <span class="nf">qvmul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vector rotation</span>

<span class="sd">    :arg q: unit-quaternion</span>
<span class="sd">    :type q: array_like(4)</span>
<span class="sd">    :arg v: 3-vector to be rotated</span>
<span class="sd">    :type v: array_like(3)</span>
<span class="sd">    :return: rotated 3-vector</span>
<span class="sd">    :rtype: ndarray(3)</span>

<span class="sd">    The vector `v` is rotated about the origin by the SO(3) equivalent of the unit</span>
<span class="sd">    quaternion.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qvmul</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q = [1/sqrt(2), 1/sqrt(2), 0, 0]  # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; qvmul(q, [1, 2, 3])              # rotated vector</span>

<span class="sd">    .. warning:: There is no check that the passed value is a unit-quaternions.</span>

<span class="sd">    :seealso: qvmul</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">qv</span> <span class="o">=</span> <span class="n">qqmul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qqmul</span><span class="p">(</span><span class="n">qpure</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">qconj</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span></div>


<div class="viewcode-block" id="vvmul"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.vvmul">[docs]</a><span class="k">def</span> <span class="nf">vvmul</span><span class="p">(</span><span class="n">qa</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion multiplication</span>


<span class="sd">    :arg qa: left-hand quaternion</span>
<span class="sd">    :type qa: : array_like(3)</span>
<span class="sd">    :arg qb: right-hand quaternion</span>
<span class="sd">    :type qb: array_like(3)</span>
<span class="sd">    :return: quaternion product</span>
<span class="sd">    :rtype: ndarray(3)</span>

<span class="sd">    This is the quaternion or Hamilton product of unit-quaternions defined only</span>
<span class="sd">    by their vector components.  The product will be a unit-quaternion, defined only</span>
<span class="sd">    by its vector component.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import vvmul, v2q, q2v, qqmul, qprint</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1/sqrt(2), 1/sqrt(2), 0, 0]  # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; q2 = [1/sqrt(2), 0, 1/sqrt(2), 0]  # 90deg rotation about y-axis</span>
<span class="sd">        &gt;&gt;&gt; qprint(qqmul(q1, q2))              # normal Hamilton product</span>
<span class="sd">        &gt;&gt;&gt; v1 = q2v(q1); v2 = q2v(q2)</span>
<span class="sd">        &gt;&gt;&gt; vp = vvmul(v1, v2)                 # product using 3-vectors</span>
<span class="sd">        &gt;&gt;&gt; qprint(v2q(vp))                    # same answer as Hamilton product</span>

<span class="sd">    :seealso: :func:`q2v`, :func:`v2q`, :func:`qvmul`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t6</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qa</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">t11</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qb</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span>
        <span class="n">qa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">qb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t6</span> <span class="o">+</span> <span class="n">qa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t11</span><span class="p">,</span>
        <span class="o">-</span><span class="n">qa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">qa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t6</span> <span class="o">+</span> <span class="n">qa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t11</span><span class="p">,</span>
        <span class="n">qa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">qb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">qa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">t6</span> <span class="o">+</span> <span class="n">qa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">t11</span><span class="p">,</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="qpow"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qpow">[docs]</a><span class="k">def</span> <span class="nf">qpow</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise quaternion to a power</span>

<span class="sd">    :arg q: quaternion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :arg power: exponent</span>
<span class="sd">    :type power: int</span>
<span class="sd">    :return: input quaternion raised to the specified power</span>
<span class="sd">    :rtype: ndarray(4)</span>
<span class="sd">    :raises ValueError: if exponent is non integer</span>

<span class="sd">    Raises a quaternion to the specified power using repeated multiplication.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qpow, qqmul, qprint</span>
<span class="sd">        &gt;&gt;&gt; q = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; qprint(qqmul(q, q))</span>
<span class="sd">        &gt;&gt;&gt; qprint(qpow(q, 2))</span>
<span class="sd">        &gt;&gt;&gt; qprint(qpow(q, -2)) # conjugate of above</span>

<span class="sd">    .. note:</span>

<span class="sd">        - Power must be an integer</span>
<span class="sd">        - Power can be negative, in which case the conjugate is taken</span>

<span class="sd">    :seealso: :func:`qqmul`</span>
<span class="sd">    :SymPy: supported for ``q`` but not ``power``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Power must be an integer&quot;</span><span class="p">)</span>
    <span class="n">qr</span> <span class="o">=</span> <span class="n">qeye</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">power</span><span class="p">)):</span>
        <span class="n">qr</span> <span class="o">=</span> <span class="n">qqmul</span><span class="p">(</span><span class="n">qr</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">qr</span> <span class="o">=</span> <span class="n">qconj</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qr</span></div>


<div class="viewcode-block" id="qconj"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qconj">[docs]</a><span class="k">def</span> <span class="nf">qconj</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion conjugate</span>

<span class="sd">    :arg q: quaternion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :return: conjugate of input quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    Conjugate of quaternion, the vector part is negated.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qconj, qprint</span>
<span class="sd">        &gt;&gt;&gt; q = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; qprint(qconj(q))</span>

<span class="sd">    :SymPy: supported</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]]</span></div>


<div class="viewcode-block" id="q2r"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.q2r">[docs]</a><span class="k">def</span> <span class="nf">q2r</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;sxyz&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert unit-quaternion to SO(3) rotation matrix</span>

<span class="sd">    :arg q: unit-quaternion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :param order: the order of the quaternion elements. Must be &#39;sxyz&#39; or</span>
<span class="sd">        &#39;xyzs&#39;. Defaults to &#39;sxyz&#39;.</span>
<span class="sd">    :type order: str</span>
<span class="sd">    :return: corresponding SO(3) rotation matrix</span>
<span class="sd">    :rtype: ndarray(3,3)</span>

<span class="sd">    Returns an SO(3) rotation matrix corresponding to this unit-quaternion.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import q2r</span>
<span class="sd">        &gt;&gt;&gt; q = [0, 0, 1, 0]  # rotation of 180deg about y-axis</span>
<span class="sd">        &gt;&gt;&gt; print(q2r(q))</span>

<span class="sd">    .. warning:: There is no check that the passed value is a unit-quaternion.</span>

<span class="sd">    :seealso: :func:`r2q`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;sxyz&quot;</span><span class="p">:</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;xyzs&quot;</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order is invalid, must be &#39;sxyz&#39; or &#39;xyzs&#39;&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">z</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span><span class="p">)],</span>
            <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="p">)],</span>
            <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)],</span>
        <span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="r2q"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.r2q">[docs]</a><span class="k">def</span> <span class="nf">r2q</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;sxyz&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert SO(3) rotation matrix to unit-quaternion</span>

<span class="sd">    :arg R: SO(3) rotation matrix</span>
<span class="sd">    :type R: ndarray(3,3)</span>
<span class="sd">    :param check: check validity of rotation matrix, default False</span>
<span class="sd">    :type check: bool</span>
<span class="sd">    :param tol: tolerance in units of eps</span>
<span class="sd">    :type tol: float</span>
<span class="sd">    :param order: the order of the returned quaternion elements. Must be &#39;sxyz&#39; or</span>
<span class="sd">        &#39;xyzs&#39;. Defaults to &#39;sxyz&#39;.</span>
<span class="sd">    :type order: str</span>
<span class="sd">    :return: unit-quaternion as Euler parameters</span>
<span class="sd">    :rtype: ndarray(4)</span>
<span class="sd">    :raises ValueError: for non SO(3) argument</span>

<span class="sd">    Returns a unit-quaternion corresponding to the input SO(3) rotation matrix.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import r2q, qprint, rotx</span>
<span class="sd">        &gt;&gt;&gt; R = rotx(90, &#39;deg&#39;) # rotation of 90deg about x-axis</span>
<span class="sd">        &gt;&gt;&gt; print(R)</span>
<span class="sd">        &gt;&gt;&gt; qprint(r2q(R))</span>

<span class="sd">    .. warning:: There is no check that the passed matrix is a valid rotation matrix.</span>

<span class="sd">    .. note::</span>
<span class="sd">        - Scalar part is always positive</span>
<span class="sd">        - implements Cayley&#39;s method</span>

<span class="sd">    :reference:</span>
<span class="sd">        - Sarabandi, S., and Thomas, F. (March 1, 2019).</span>
<span class="sd">          &quot;A Survey on the Computation of Quaternions From Rotation Matrices.&quot;</span>
<span class="sd">          ASME. J. Mechanisms Robotics. April 2019; 11(2): 021006.</span>
<span class="sd">          `doi.org/10.1115/1.4041889 &lt;https://doi.org/10.1115/1.4041889&gt;`_</span>

<span class="sd">    :seealso: :func:`q2r`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be a valid SO(3) matrix&quot;</span><span class="p">)</span>

    <span class="n">t12p</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">t13p</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">t23p</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">t12m</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">t13m</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">t23m</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">d1</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">d3</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">d4</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">e0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d1</span> <span class="o">+</span> <span class="n">t23m</span> <span class="o">+</span> <span class="n">t13m</span> <span class="o">+</span> <span class="n">t12m</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t23m</span> <span class="o">+</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">t12p</span> <span class="o">+</span> <span class="n">t13p</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t13m</span> <span class="o">+</span> <span class="n">t12p</span> <span class="o">+</span> <span class="n">d3</span> <span class="o">+</span> <span class="n">t23p</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>
    <span class="n">e3</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t12m</span> <span class="o">+</span> <span class="n">t13p</span> <span class="o">+</span> <span class="n">t23p</span> <span class="o">+</span> <span class="n">d4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>

    <span class="c1"># transfer sign from rotation element differences</span>
    <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="o">-</span><span class="n">e1</span>
    <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="o">-</span><span class="n">e2</span>
    <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="n">e3</span> <span class="o">=</span> <span class="o">-</span><span class="n">e3</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;sxyz&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;xyzs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">,</span> <span class="n">e0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order is invalid, must be &#39;sxyz&#39; or &#39;xyzs&#39;&quot;</span><span class="p">)</span></div>


<span class="c1"># def r2q_old(R, check=False, tol=100):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Convert SO(3) rotation matrix to unit-quaternion</span>

<span class="c1">#     :arg R: SO(3) rotation matrix</span>
<span class="c1">#     :type R: ndarray(3,3)</span>
<span class="c1">#     :param check: check validity of rotation matrix, default False</span>
<span class="c1">#     :type check: bool</span>
<span class="c1">#     :param tol: tolerance in units of eps</span>
<span class="c1">#     :type tol: float</span>
<span class="c1">#     :return: unit-quaternion</span>
<span class="c1">#     :rtype: ndarray(4)</span>
<span class="c1">#     :raises ValueError: for non SO(3) argument</span>

<span class="c1">#     Returns a unit-quaternion corresponding to the input SO(3) rotation matrix.</span>

<span class="c1">#     .. runblock:: pycon</span>

<span class="c1">#         &gt;&gt;&gt; from spatialmath.base import r2q, qprint, rotx</span>
<span class="c1">#         &gt;&gt;&gt; R = rotx(90, &#39;deg&#39;) # rotation of 90deg about x-axis</span>
<span class="c1">#         &gt;&gt;&gt; print(R)</span>
<span class="c1">#         &gt;&gt;&gt; qprint(r2q(R))</span>

<span class="c1">#     .. warning:: There is no check that the passed matrix is a valid rotation matrix.</span>

<span class="c1">#     .. note:: Scalar part is always positive.</span>

<span class="c1">#     :seealso: :func:`q2r`</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     if not base.isrot(R, check=check, tol=tol):</span>
<span class="c1">#         raise ValueError(&quot;Argument must be a valid SO(3) matrix&quot;)</span>

<span class="c1">#     qs = math.sqrt(max(0, np.trace(R) + 1)) / 2.0  # scalar part</span>
<span class="c1">#     kx = R[2, 1] - R[1, 2]  # Oz - Ay</span>
<span class="c1">#     ky = R[0, 2] - R[2, 0]  # Ax - Nz</span>
<span class="c1">#     kz = R[1, 0] - R[0, 1]  # Ny - Ox</span>

<span class="c1">#     if (R[0, 0] &gt;= R[1, 1]) and (R[0, 0] &gt;= R[2, 2]):</span>
<span class="c1">#         kx1 = R[0, 0] - R[1, 1] - R[2, 2] + 1  # Nx - Oy - Az + 1</span>
<span class="c1">#         ky1 = R[1, 0] + R[0, 1]  # Ny + Ox</span>
<span class="c1">#         kz1 = R[2, 0] + R[0, 2]  # Nz + Ax</span>
<span class="c1">#         add = (kx &gt;= 0)</span>
<span class="c1">#     elif R[1, 1] &gt;= R[2, 2]:</span>
<span class="c1">#         kx1 = R[1, 0] + R[0, 1]  # Ny + Ox</span>
<span class="c1">#         ky1 = R[1, 1] - R[0, 0] - R[2, 2] + 1  # Oy - Nx - Az + 1</span>
<span class="c1">#         kz1 = R[2, 1] + R[1, 2]  # Oz + Ay</span>
<span class="c1">#         add = (ky &gt;= 0)</span>
<span class="c1">#     else:</span>
<span class="c1">#         kx1 = R[2, 0] + R[0, 2]  # Nz + Ax</span>
<span class="c1">#         ky1 = R[2, 1] + R[1, 2]  # Oz + Ay</span>
<span class="c1">#         kz1 = R[2, 2] - R[0, 0] - R[1, 1] + 1  # Az - Nx - Oy + 1</span>
<span class="c1">#         add = (kz &gt;= 0)</span>

<span class="c1">#     if add:</span>
<span class="c1">#         kx = kx + kx1</span>
<span class="c1">#         ky = ky + ky1</span>
<span class="c1">#         kz = kz + kz1</span>
<span class="c1">#     else:</span>
<span class="c1">#         kx = kx - kx1</span>
<span class="c1">#         ky = ky - ky1</span>
<span class="c1">#         kz = kz - kz1</span>

<span class="c1">#     kv = np.r_[kx, ky, kz]</span>
<span class="c1">#     nm = np.linalg.norm(kv)</span>
<span class="c1">#     if abs(nm) &lt; tol * _eps:</span>
<span class="c1">#         return eye()</span>
<span class="c1">#     else:</span>
<span class="c1">#         return np.r_[qs, (math.sqrt(1.0 - qs ** 2) / nm) * kv]</span>


<div class="viewcode-block" id="qslerp"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qslerp">[docs]</a><span class="k">def</span> <span class="nf">qslerp</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quaternion conjugate</span>

<span class="sd">    :arg q0: initial unit quaternion</span>
<span class="sd">    :type q0: array_like(4)</span>
<span class="sd">    :arg q1: final unit quaternion</span>
<span class="sd">    :type q1: array_like(4)</span>
<span class="sd">    :arg s: interpolation coefficient in the range [0,1]</span>
<span class="sd">    :type s: float</span>
<span class="sd">    :arg shortest: choose shortest distance [default False]</span>
<span class="sd">    :type shortest: bool</span>
<span class="sd">    :return: interpolated unit-quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>
<span class="sd">    :raises ValueError: s is outside interval [0, 1]</span>

<span class="sd">    An interpolated quaternion between ``q0`` when ``s`` = 0 to ``q1`` when ``s`` = 1.</span>

<span class="sd">    Interpolation is performed on a great circle on a 4D hypersphere. This is</span>
<span class="sd">    a rotation about a single fixed axis in space which yields the straightest</span>
<span class="sd">    and shortest path between two points.</span>

<span class="sd">    For large rotations the path may be the *long way around* the circle,</span>
<span class="sd">    the option ``&#39;shortest&#39;`` ensures always the shortest path.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qslerp, qprint</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q0 = [1/sqrt(2), 1/sqrt(2), 0, 0]  # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1/sqrt(2), 0, 1/sqrt(2), 0]  # 90deg rotation about y-axis</span>
<span class="sd">        &gt;&gt;&gt; qprint(qslerp(q0, q1, 0))           # this is q0</span>
<span class="sd">        &gt;&gt;&gt; qprint(qslerp(q0, q1, 1))           # this is q1</span>
<span class="sd">        &gt;&gt;&gt; qprint(qslerp(q0, q1, 0.5))         # this is in &quot;half way&quot; between</span>

<span class="sd">    .. warning:: There is no check that the passed values are unit-quaternions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s must be in the interval [0,1]&quot;</span><span class="p">)</span>
    <span class="n">q0</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q1</span>

    <span class="n">dotprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>

    <span class="c1"># If the dot product is negative, the quaternions</span>
    <span class="c1"># have opposite handed-ness and slerp won&#39;t take</span>
    <span class="c1"># the shorter path. Fix by reversing one quaternion.</span>
    <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dotprod</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="o">-</span><span class="n">q0</span>  <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
            <span class="n">dotprod</span> <span class="o">=</span> <span class="o">-</span><span class="n">dotprod</span>  <span class="c1"># pylint: disable=invalid-unary-operand-type</span>

    <span class="n">dotprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dotprod</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Clip within domain of acos()</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">dotprod</span><span class="p">)</span>  <span class="c1"># theta is the angle between rotation vectors</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">_eps</span><span class="p">:</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">q0</span> <span class="o">*</span> <span class="n">s0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q1</span> <span class="o">*</span> <span class="n">s1</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># quaternions are identical</span>
        <span class="k">return</span> <span class="n">q0</span></div>


<div class="viewcode-block" id="qrand"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qrand">[docs]</a><span class="k">def</span> <span class="nf">qrand</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random unit-quaternion</span>

<span class="sd">    :return: random unit-quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    Computes a uniformly distributed random unit-quaternion which can be</span>
<span class="sd">    considered equivalent to a random SO(3) rotation.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qrand, qprint</span>
<span class="sd">        &gt;&gt;&gt; qprint(qrand())</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># get 3 random numbers in [0,1]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span>
        <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="qmatrix"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qmatrix">[docs]</a><span class="k">def</span> <span class="nf">qmatrix</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert quaternion to 4x4 matrix equivalent</span>

<span class="sd">    :arg q: quaternion</span>
<span class="sd">    :type v: array_like(4)</span>
<span class="sd">    :return: equivalent matrix</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    Hamilton multiplication between two quaternions can be considered as a</span>
<span class="sd">    matrix-vector product, the left-hand quaternion is represented by an</span>
<span class="sd">    equivalent 4x4 matrix and the right-hand quaternion as 4x1 column vector.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qmatrix, qqmul, qprint</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; q2 = [5, 6, 7, 8]</span>
<span class="sd">        &gt;&gt;&gt; qqmul(q1, q2)    # conventional Hamilton product</span>
<span class="sd">        &gt;&gt;&gt; m = qmatrix(q1)</span>
<span class="sd">        &gt;&gt;&gt; print(m)</span>
<span class="sd">        &gt;&gt;&gt; v = m @ np.array(q2)</span>
<span class="sd">        &gt;&gt;&gt; print(v)</span>

<span class="sd">    :seealso: qqmul</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">z</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">]])</span></div>


<div class="viewcode-block" id="qdot"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qdot">[docs]</a><span class="k">def</span> <span class="nf">qdot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rate of change of unit-quaternion</span>

<span class="sd">    :arg q0: unit-quaternion</span>
<span class="sd">    :type q0: array_like(4)</span>
<span class="sd">    :arg w: 3D angular velocity in world frame</span>
<span class="sd">    :type w: array_like(3)</span>
<span class="sd">    :return: rate of change of unit quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    ``dot(q, w)`` is the rate of change of the elements of the unit quaternion ``q``</span>
<span class="sd">    which represents the orientation of a body frame with angular velocity ``w`` in</span>
<span class="sd">    the world frame.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qdot, qprint</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q = [1/sqrt(2), 1/sqrt(2), 0, 0]   # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; qdot(q, [1, 2, 3])</span>

<span class="sd">    .. warning:: There is no check that the passed values are unit-quaternions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">-</span> <span class="n">base</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">w</span><span class="p">),</span> <span class="n">E</span> <span class="o">@</span> <span class="n">w</span><span class="p">]</span></div>


<div class="viewcode-block" id="qdotb"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qdotb">[docs]</a><span class="k">def</span> <span class="nf">qdotb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rate of change of unit-quaternion</span>

<span class="sd">    :arg q0: unit-quaternion</span>
<span class="sd">    :type q0: array_like(4)</span>
<span class="sd">    :arg w: 3D angular velocity in body frame</span>
<span class="sd">    :type w: array_like(3)</span>
<span class="sd">    :return: rate of change of unit quaternion</span>
<span class="sd">    :rtype: ndarray(4)</span>

<span class="sd">    ``dotb(q, w)`` is the rate of change of the elements of the unit quaternion ``q``</span>
<span class="sd">    which represents the orientation of a body frame with angular velocity ``w`` in</span>
<span class="sd">    the body frame.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qdotb, qprint</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q = [1/sqrt(2), 1/sqrt(2), 0, 0]   # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; qdotb(q, [1, 2, 3])</span>

<span class="sd">    .. warning:: There is no check that the passed values are unit-quaternions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">w</span><span class="p">),</span> <span class="n">E</span> <span class="o">@</span> <span class="n">w</span><span class="p">]</span></div>


<div class="viewcode-block" id="qangle"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qangle">[docs]</a><span class="k">def</span> <span class="nf">qangle</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Angle between two unit-quaternions</span>

<span class="sd">    :arg q0: unit-quaternion</span>
<span class="sd">    :type q0: array_like(4)</span>
<span class="sd">    :arg q1: unit-quaternion</span>
<span class="sd">    :type q1: array_like(4)</span>
<span class="sd">    :return: angle between the rotations [radians]</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    If each of the input quaternions is considered a rotated coordinate</span>
<span class="sd">    frame, then the angle is the smallest rotation required about a fixed</span>
<span class="sd">    axis, to rotate the first frame into the second.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qangle</span>
<span class="sd">        &gt;&gt;&gt; from math import sqrt</span>
<span class="sd">        &gt;&gt;&gt; q1 = [1/sqrt(2), 1/sqrt(2), 0, 0]    # 90deg rotation about x-axis</span>
<span class="sd">        &gt;&gt;&gt; q2 = [1/sqrt(2), 0, 1/sqrt(2), 0]    # 90deg rotation about y-axis</span>
<span class="sd">        &gt;&gt;&gt; qangle(q1, q2)</span>

<span class="sd">    :References:</span>

<span class="sd">    - Metrics for 3D rotations: comparison and analysis,</span>
<span class="sd">      Du Q. Huynh, % J.Math Imaging Vis. DOFI 10.1007/s10851-009-0161-2.</span>

<span class="sd">    .. warning:: There is no check that the passed values are unit-quaternions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO different methods</span>

    <span class="n">q1</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">q1</span> <span class="o">-</span> <span class="n">q2</span><span class="p">),</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">q1</span> <span class="o">+</span> <span class="n">q2</span><span class="p">))</span></div>


<div class="viewcode-block" id="qprint"><a class="viewcode-back" href="../../../func_quat.html#spatialmath.base.quaternions.qprint">[docs]</a><span class="k">def</span> <span class="nf">qprint</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">),</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{: .4f}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format a quaternion</span>

<span class="sd">    :arg q: unit-quaternion</span>
<span class="sd">    :type q: array_like(4)</span>
<span class="sd">    :arg delim: 2-list of delimeters [default (&#39;&lt;&#39;, &#39;&gt;&#39;)]</span>
<span class="sd">    :type delim: list or tuple of strings</span>
<span class="sd">    :arg fmt: printf-style format soecifier [default &#39;{: .4f}&#39;]</span>
<span class="sd">    :type fmt: str</span>
<span class="sd">    :arg file: destination for formatted string [default sys.stdout]</span>
<span class="sd">    :type file: file object</span>
<span class="sd">    :return: formatted string</span>
<span class="sd">    :rtype: str</span>

<span class="sd">    Format the quaternion in a human-readable form as::</span>

<span class="sd">        S  D1  VX VY VZ D2</span>

<span class="sd">    where S, VX, VY, VZ are the quaternion elements, and D1 and D2 are a pair</span>
<span class="sd">    of delimeters given by `delim`.</span>

<span class="sd">    By default the string is written to `sys.stdout`.</span>

<span class="sd">    If `file=None` then a string is returned.</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from spatialmath.base import qprint, qrand</span>
<span class="sd">        &gt;&gt;&gt; q = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; qprint(q)</span>
<span class="sd">        &gt;&gt;&gt; q = qrand()   # a unit quaternion</span>
<span class="sd">        &gt;&gt;&gt; qprint(q, delim=(&#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;# </span><span class="si">{}</span><span class="s2"> #, #, # </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">delim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">delim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">import</span> <span class="nn">pathlib</span>

    <span class="n">exec</span><span class="p">(</span>
        <span class="nb">open</span><span class="p">(</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
            <span class="o">/</span> <span class="s2">&quot;tests&quot;</span>
            <span class="o">/</span> <span class="s2">&quot;base&quot;</span>
            <span class="o">/</span> <span class="s2">&quot;test_quaternions.py&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>  <span class="c1"># pylint: disable=exec-used</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-, Peter Corke..
      <span class="lastupdated">Last updated on 27-Jan-2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>